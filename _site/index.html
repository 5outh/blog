<!doctype html>
<html>
  <ul class="social_links">
    <li><a href="http://www.github.com/5outh"><img src="./images/github.png" class="githublink"></a></li>
    <li><a href="http://www.twitter.com/bendotk"><img src="./images/twitter.png" class="twitterlink"></a></li>
    <li><a href="https://www.linkedin.com/pub/benjamin-kovach/39/242/57b"><img src="./images/linkedin.png" class="linkedinlink"></a></li>
  </ul>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Abstract Nonsense</title>
    
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="stylesheet" href="./css/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!-- <link rel="stylesheet" type="text/css" href="/css/default.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/syntax.css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <link href="http://fonts.googleapis.com/css?family=Alegreya+Sans+SC|Della+Respira|Montaga|Open+Sans:400italic,400,700|Roboto:400,100|Source+Code+Pro" rel="stylesheet" type="text/css">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 id="blog_title"><a href="./">Abstract Nonsense</a></h1>
        <p id="blog_subtitle">Ramblings by Benjamin Kovach</p>
        <ul>
            <li><a href="./">Home</a></li>
            <li><a href="./projects.html">Projects</a></li>
            <li><a href="./contact.html">About</a></li>
            <li><a href="./cv.html">CV</a></li>
            <li><a href="./archive.html">Archive</a></li>
            <li><a href="./notes.html">Notes</a></li>
            <li><a href="./atom.xml">Atom</a></li>
        </ul>
         <p style="line-height:10px;"><small>Theme adapted from minimal by <a href="https://github.com/orderedlist">orderedlist</a>.</small></p>
      </header>
      <section>
        <center>
            
            
            
        </center>
        <p><ul class="blog_list">
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-08-09-twitter.html">Posting to Twitter via HTTP in haskell</a>
	<p class="published">Published by Ben Kovach on August  9, 2014</p>
</div>
<div class="post_body">
	<p>When working on <a href="https://twitter.com/_rapcandy">rapcandy</a>, I had a bit of trouble getting the twitter connector bit working. I’ll detail here what worked – if you need to connect to Twitter via one of your Haskell applications, this should help you out.</p>
<h3 id="setting-up-a-twitter-application">Setting up a Twitter Application</h3>
<p>In order to interact with Twitter programmatically, you’ll first need to set up an application via <a href="http://dev.twitter.com">dev.twitter.com</a>. You can create a new app here and generate new API keys for it. Once you do this, you’ll be able to <em>read</em> from twitter. If you want to write to twitter (like I did, with <a href="https://twitter.com/_rapcandy">@_rapcandy</a>), you can go to the <em>API Keys</em> tab, click “modify app permissions” and give it write access. You can then generate new API keys which will permit writing.</p>
<p>Copy down your API key, API secret, Access token, and Access token secret into a JSON file called <code>config.json</code> that looks like this:</p>
<pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
    <span class="dt">&quot;apiKey&quot;</span><span class="fu">:</span> <span class="st">&quot;&lt;api key&gt;&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;apiSecret&quot;</span><span class="fu">:</span> <span class="st">&quot;&lt;api secret&gt;&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;userKey&quot;</span><span class="fu">:</span> <span class="st">&quot;&lt;user key&gt;&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;userSecret&quot;</span><span class="fu">:</span> <span class="st">&quot;&lt;user secret&gt;&quot;</span>
<span class="fu">}</span></code></pre>
<p>Now everything’s in place to be able to start interacting with Twitter via Haskell.</p>
<h3 id="posting-to-twitter">Posting to Twitter</h3>
<p>We’ll be using <code>aeson</code>, <code>HTTP</code>, and <code>authenticate-oauth</code> (Twitter uses OAuth to authenticate its users) to handle the transaction. A bit of boilerplate:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric             #-}</span>
<span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings         #-}</span>
<span class="ot">{-# LANGUAGE RecordWildCards           #-}</span>

<span class="kw">import           </span><span class="dt">Control.Monad</span>
<span class="kw">import           </span><span class="dt">Data.Aeson</span>
<span class="kw">import           </span><span class="dt">GHC.Generics</span>
<span class="kw">import           </span><span class="dt">Data.ByteString</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span>   <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span>    <span class="kw">as</span> <span class="dt">BL</span>
<span class="kw">import qualified</span> <span class="dt">Network.HTTP.Base</span>       <span class="kw">as</span> <span class="dt">HTTP</span>
<span class="kw">import           </span><span class="dt">Network.HTTP.Client</span>
<span class="kw">import           </span><span class="dt">Network.HTTP.Client.TLS</span>
<span class="kw">import           </span><span class="dt">Network.HTTP.Types</span>
<span class="kw">import           </span><span class="dt">Web.Authenticate.OAuth</span></code></pre>
<p>First thing’s first, we need to be able to pull in our config file in order to access the keys for our application. We “magically” do this using <code>Aeson</code>, deriving <code>Generic</code> and making automatic instances of <code>{To, From}JSON</code> for our user-defined <code>Config</code> type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span> {
<span class="ot">    apiKey       ::</span> <span class="dt">String</span>,
<span class="ot">    apiSecret    ::</span> <span class="dt">String</span>,
<span class="ot">    userKey      ::</span> <span class="dt">String</span>,
<span class="ot">    userSecret   ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Config</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Config</span></code></pre>
<p>We can pull in a <code>Config</code> from a file with a basic function <code>configFromFile</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">configFromFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Config</span>)
configFromFile path <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile path
  return <span class="fu">$</span> eitherDecode contents</code></pre>
<p>Now calling <code>configFromFile &quot;config.json&quot;</code> should return something like <code>Right (Config{...})</code>. Now we can start authenticating requests to the Twitter API. The following function is adapted from the <a href="http://hackage.haskell.org/package/yesod-auth-0.7.2/docs/src/Yesod-Auth-OAuth.html">Yesod source code</a> to be less specific to Yesod:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">oauthTwitter ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">OAuth</span>
oauthTwitter key secret <span class="fu">=</span>
  newOAuth { oauthServerName      <span class="fu">=</span> <span class="st">&quot;twitter&quot;</span>
           , oauthRequestUri      <span class="fu">=</span> <span class="st">&quot;https://api.twitter.com/oauth/request_token&quot;</span>
           , oauthAccessTokenUri  <span class="fu">=</span> <span class="st">&quot;https://api.twitter.com/oauth/access_token&quot;</span>
           , oauthAuthorizeUri    <span class="fu">=</span> <span class="st">&quot;https://api.twitter.com/oauth/authorize&quot;</span>
           , oauthSignatureMethod <span class="fu">=</span> <span class="dt">HMACSHA1</span>
           , oauthConsumerKey     <span class="fu">=</span> key
           , oauthConsumerSecret  <span class="fu">=</span> secret
           , oauthVersion         <span class="fu">=</span> <span class="dt">OAuth10a</span>
           }</code></pre>
<p>Here we pass in our OAuth consumer key and secret to build an <code>OAuth</code>; these correspond to the Twitter API key/secret, and is one half of what we need to fully authenticate Twitter requests. The other half is a <code>Credential</code>, which we can build with <code>newCredential</code> using our <em>user</em> key and secret. We can fully sign an arbitrary request using a <code>Config</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">signWithConfig ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Request</span>
signWithConfig <span class="dt">Config</span>{<span class="fu">..</span>} <span class="fu">=</span> signOAuth
  (oauthTwitter (B.pack apiKey) (B.pack apiSecret))
  (newCredential (B.pack userKey) (B.pack userSecret))</code></pre>
<p>Now all we have to do is actually <em>send</em> a request (post a status!), which is simple but took me a while to finagle into place. There are three things to keep in mind here:</p>
<ol style="list-style-type: decimal">
<li>We must <code>urlEncode</code> the status we want to send.</li>
<li>We must <code>POST</code>; not <code>GET</code>.</li>
<li>We must use <code>tlsManagerSettings</code> to enable TLS for our request (otherwise, the request won’t go through)</li>
</ol>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tweet ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">BL.ByteString</span>)
tweet config status <span class="fu">=</span> <span class="kw">do</span>
  url <span class="ot">&lt;-</span> parseUrl <span class="fu">$</span> <span class="st">&quot;https://api.twitter.com/1.1/statuses/update.json?status=&quot;</span> <span class="fu">++</span> HTTP.urlEncode status
  req <span class="ot">&lt;-</span> signWithConfig config url{ method <span class="fu">=</span> <span class="st">&quot;POST&quot;</span> }
  manager <span class="ot">&lt;-</span> newManager tlsManagerSettings
  httpLbs req manager</code></pre>
<p>Using this code and a sufficiently permissive Twitter application, you should be able to adapt this code to send requests to any of the <a href="https://dev.twitter.com/docs/api/1.1">Twitter REST API endpoints</a> from Haskell.</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-08-09-twitter.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-08-04-markov-chains.html">Modeling and Simulating Markov Chain Evolution</a>
	<p class="published">Published by Ben Kovach on August  4, 2014</p>
</div>
<div class="post_body">
	<p>In this post, I will describe and implement a small interface for modeling Markov chains and simulating their evolution in Haskell.</p>
<h3 id="what-is-a-markov-chain">What is a Markov Chain?</h3>
<p>
<p><small width="200px" style="float:right; text-align:center"><a href="http://commons.wikimedia.org/wiki/File:Markovkate_01.svg#mediaviewer/File:Markovkate_01.svg"><img width="260px" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Markovkate_01.svg/1200px-Markovkate_01.svg.png" alt="Markovkate 01.svg"></a><br>A simple two-state Markov chain.<br>image by <a href="//commons.wikimedia.org/wiki/User:Joxemai4" title="User:Joxemai4">Joxemai4</a>.</small></p>
A <a href="http://en.wikipedia.org/wiki/Markov_chain">discrete-time Markov chain (DTMC)</a> is a mathematical system that probabalistically transitions between states using only its current state. A Markov chain can be thought of as a directed graph with probabilities for edges and states for vertices. The Markov chain on the right has two states, <code>E</code> and <code>A</code>. The diagram states that a Markov chain in state <code>E</code> will transition back to state <code>E</code> with probability <code>0.3</code>, and to state <code>A</code> with probability <code>0.7</code>, and similarly for <code>A</code>’s transitions. They can be used for a wide variety of applications in statistical modeling.
</p>

<p>They can also be used to generate sentences similar to arbitrary blocks of text. We will explore this application towards the end of the post.</p>
<h3 id="aside-weighted-random-generation">Aside: Weighted Random Generation</h3>
<p>The first thing that comes to mind when I think of random generation is still <a href="http://learnyouahaskell.com/for-a-few-monads-more#making-monads">the <code>Prob</code> data type described in LYAH</a>. <a href="https://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random.html">The <code>MonadRandom</code> library</a> defines a data type <a href="https://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random.html#t:Rand"><code>Rand</code></a> which works, in many ways, in the same way as the <code>Prob</code> data type does (with a bit of extension to produce a transormer, etc.). I won’t go into the full details of how this works, but the basic ideas is that, given a list of outcomes with weights, e.g.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[(<span class="st">&quot;Heads&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;Tails&quot;</span>, <span class="dv">1</span>)]</code></pre>
<p>we can – by wrapping it in <code>Rand</code> and giving it a random generator – produce a weighted random outcome, “Heads” or “Tails” with the desired weighting. For a concrete example, here’s a functional program written using the <code>MonadRandom</code> library.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Random</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> newStdGen <span class="fu">&gt;&gt;=</span> print <span class="fu">.</span> evalRand coinFlip
  <span class="kw">where</span> coinFlip <span class="fu">=</span> uniform [<span class="st">&quot;Heads&quot;</span>, <span class="st">&quot;Tails&quot;</span>]</code></pre>
<p><code>uniform</code> constructs a <code>Rand</code> from a list with a uniform distribution, i.e. with each member having the same weight. <code>evalRand</code> takes a <code>Rand</code> and a random generator (we’re using <code>StdGen</code> here with <code>newStdGen</code>) and spits out a weighted random object. Running this will print “Heads” about 50% of the time and “Tails” about 50% of the time.</p>
<p>Also of note is the <code>fromList</code> combinator, which takes a list of objects and their weights and constructs a <code>Rand</code> object. For example, replacing <code>coinFlip</code> with <code>fromList [(&quot;Heads&quot;, 1), (&quot;Tails&quot;, 1)]</code> yields the same program as above.</p>
<h3 id="markov-chains-an-intermediate-representation">Markov Chains: An Intermediate Representation</h3>
<p>In order to model Markov chains, we essentially want to build a graph with weighted edges. We can model edge-weighted graphs using a <code>HashMap</code> from vertices to lists of edges, represented as <code>(vertex, weight)</code> pairs (the vertex the edge points to and its weight).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.HashMap.Lazy</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import           </span><span class="dt">Data.Ratio</span>

<span class="kw">type</span> <span class="dt">MarkovI</span> a <span class="fu">=</span> <span class="dt">M.HashMap</span> a (<span class="dt">Maybe</span> [(a, <span class="dt">Rational</span>)])</code></pre>
<p>The <code>MarkovI</code> (<code>I</code> for “intermediate”) data type is a synonym for a lazy <code>HashMap</code> from <code>a</code> to a list of vertex-edge pairs. The only difference here is that we allow the list to be empty by using <code>Maybe</code>, which signifies an “end” state in the chain with no outgoing transitions. We could remove this wrapper and use an empty list to signify the same thing, but this representation works better with <code>MonadRandom</code>, since <code>Rand</code>s can’t be empty, making the translation straightforward.</p>
<p>You might also be wondering why we need an intermediate representation for Markov chains in the first place. The reason for this is that we can’t arbitrarily insert extra objects/weights into <code>Rand</code>s, and we’ll want to build up the mappings piecemeal. We need some intermediate structure to handle this functionality.</p>
<p>We can define functions to build up <code>MarkovI</code>s via insertion of objects:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMkvI ::</span> (<span class="dt">Hashable</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MarkovI</span> a <span class="ot">-&gt;</span> <span class="dt">MarkovI</span> a
insertMkvI r k v mkv <span class="fu">=</span> M.insert k (<span class="dt">Just</span> <span class="fu">$</span> <span class="kw">case</span> M.lookup k mkv <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> [(v, r)]
  <span class="dt">Just</span> xs <span class="ot">-&gt;</span> <span class="kw">case</span> xs <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> [(v, r)]
    <span class="dt">Just</span> ys <span class="ot">-&gt;</span> (v, r)<span class="fu">:</span>ys) mkv

<span class="ot">insertEnd ::</span> (<span class="dt">Hashable</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MarkovI</span> a <span class="ot">-&gt;</span> <span class="dt">MarkovI</span> a
insertEnd k <span class="fu">=</span> M.insert k <span class="dt">Nothing</span></code></pre>
<p><code>insertMkvI</code> inserts an edge into a <code>MarkovI</code>. Its first argument is the weight for the edge being inserted. Its next two arguments are the state objects to add a transition from/to, respectively, and the fourth is the <code>MarkovI</code> to insert into. <code>insertEnd</code> inserts a state with no outbound transitions into a Markov chain.</p>
<p>It is worth noting that the <code>Rand</code> object constructed from lists like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[(<span class="dt">True</span>, <span class="dv">1</span>), (<span class="dt">True</span>, <span class="dv">1</span>), (<span class="dt">False</span>, <span class="dv">1</span>)]</code></pre>
<p><em>do</em> weight <code>True</code> twice as heavily as <code>False</code>. This will become important later, when talking about a sentence generator.</p>
<h3 id="markov-chains-final-representation">Markov Chains: Final Representation</h3>
<p>The final representation of Markov chains simply turns those <code>[(a, Rational)]</code>s in <code>MarkovI</code> into true <code>Rand</code>s.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Control.Monad.Random</span> <span class="kw">as</span> <span class="dt">R</span>

<span class="kw">newtype</span> <span class="dt">Markov</span> g a <span class="fu">=</span> <span class="dt">Markov</span>{<span class="ot"> getMarkov ::</span> <span class="dt">M.HashMap</span> a (<span class="dt">Maybe</span> (<span class="dt">R.Rand</span> g a)) }</code></pre>
<p>We can define a simple conversion function to construct <code>Markov</code>s from the intermediate representation by converting their distribution lists to <code>Rand</code>s via <code>fromList</code>. This is straightforward because empty lists are represented as <code>Nothing</code>, so we don’t have to explicitly deal with that edge case when calling <code>R.fromList</code>, which would normally fail in such a case.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromMarkovI ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">MarkovI</span> a <span class="ot">-&gt;</span> <span class="dt">Markov</span> g a
fromMarkovI <span class="fu">=</span> <span class="dt">Markov</span> <span class="fu">.</span> M.map (R.fromList <span class="fu">&lt;$&gt;</span>)</code></pre>
<p>The first goal is to be able to – given a state and a random generator – transition to a new state probabalistically. The second goal is to be able to repeat this <code>n</code> times and track the states we pass through.</p>
<p><code>runMarkov1</code> accomplishes the first goal:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Err</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Outcome</span> g a <span class="fu">=</span>
    <span class="dt">Error</span> <span class="dt">Err</span>
  <span class="fu">|</span> <span class="dt">Val</span> a g
  <span class="fu">|</span> <span class="dt">End</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="ot">runMarkov1 ::</span> (<span class="dt">R.RandomGen</span> g, <span class="dt">Hashable</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Markov</span> g a <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Outcome</span> g a
runMarkov1 mkv gen x <span class="fu">=</span> <span class="kw">case</span> M.lookup x (getMarkov mkv) <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Error</span> <span class="st">&quot;Internal error; cannot find value&quot;</span>
  <span class="dt">Just</span> rs <span class="ot">-&gt;</span> <span class="kw">case</span> flip R.runRand gen <span class="fu">&lt;$&gt;</span> rs <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">End</span>
    <span class="dt">Just</span> (a, g) <span class="ot">-&gt;</span> <span class="dt">Val</span> a g</code></pre>
<p>First, if the state we’re looking for doesn’t exist, it is impossible to transition out of it, so the computation fails with an internal error. If not, we get a probablistic value out of the transition mappings from the state in question. If there aren’t any, we just <code>End</code> – we cannot transition, but don’t really want to throw an error. If there are values to choose from, we return one along with a new random generator, wrapped in <code>Val</code>.</p>
<p>Extending this to run <code>n</code> times isn’t too tough. It mostly consists of finagling data types into the representation we want.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runMarkov ::</span> (<span class="dt">R.RandomGen</span> g, <span class="dt">Hashable</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Markov</span> g a <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> [a]
runMarkov n mkv gen x <span class="fu">=</span> go n
  <span class="kw">where</span>
    go m <span class="fu">|</span> m <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Right</span> []
         <span class="fu">|</span> otherwise <span class="fu">=</span> (x<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> <span class="kw">case</span> runMarkov1 mkv gen x <span class="kw">of</span>
            <span class="dt">Val</span> a g <span class="ot">-&gt;</span> runMarkov (n<span class="fu">-</span><span class="dv">1</span>) mkv g a
            <span class="dt">End</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> []
            <span class="dt">Error</span> err <span class="ot">-&gt;</span> <span class="dt">Left</span> err</code></pre>
<p>If we hit an <code>End</code>, the simulation terminates because it can’t progress any further. If we get an error along the way, we wrap it in <code>Left</code> and return it. Otherwise, we run <code>runMarkov1</code> repeatedly <code>n</code> times, starting from the previously computed state each time, and collecting the results into a list. If no errors occur, the result will be a list of states passed through while the simulation runs.</p>
<p>We can now define a <code>fromList</code> function, which builds up a Markov chain from mappings represented in list form.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromList ::</span> (<span class="dt">Hashable</span> a, <span class="dt">Eq</span> a, <span class="dt">R.RandomGen</span> g) <span class="ot">=&gt;</span> [(a, [(a, <span class="dt">Rational</span>)])] <span class="ot">-&gt;</span> <span class="dt">Markov</span> g a
fromList <span class="fu">=</span> <span class="dt">Markov</span> <span class="fu">.</span> foldl' (flip <span class="fu">$</span> uncurry ins) M.empty
  <span class="kw">where</span> ins a b m <span class="fu">=</span> <span class="kw">case</span> b <span class="kw">of</span>
          [] <span class="ot">-&gt;</span> M.insert a <span class="dt">Nothing</span> m
          _  <span class="ot">-&gt;</span> M.insert a (<span class="dt">Just</span> <span class="fu">$</span> R.fromList b) m</code></pre>
<p>With this at our disposal, it’s easy to model and run the example Markov chain I mentioned earlier.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example ::</span> <span class="dt">Markov</span> <span class="dt">PureMT</span> <span class="dt">String</span>
example <span class="fu">=</span> fromList [(<span class="st">&quot;E&quot;</span>, [(<span class="st">&quot;E&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;A&quot;</span>, <span class="dv">7</span>)]), (<span class="st">&quot;A&quot;</span>, [(<span class="st">&quot;E&quot;</span>, <span class="dv">4</span>), (<span class="st">&quot;A&quot;</span>, <span class="dv">6</span>)])]</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>m <span class="fu">+</span> <span class="dt">System.Random.Mersenne.Pure64</span>
λ<span class="fu">&gt;</span> gen <span class="ot">&lt;-</span> newPureMT
λ<span class="fu">&gt;</span> runMarkov <span class="dv">15</span> example gen <span class="st">&quot;E&quot;</span>
<span class="dt">Right</span> [<span class="st">&quot;E&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;E&quot;</span>,<span class="st">&quot;E&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;E&quot;</span>,<span class="st">&quot;E&quot;</span>,<span class="st">&quot;A&quot;</span>]</code></pre>
<p>The Markov chain passes through “A” a bit more often than “E”, which is to be expected from its definition.</p>
<h3 id="towards-a-sentence-generator">Towards a Sentence Generator</h3>
<p>The process of sentence generation using Markov chains is pretty simple: For each word in a “seed text,” find the probability of each other word proceeding it. Build a Markov chain out of these probabilities, using words as states, and run it a desired number of times. In order to do this, we’ll first need a utility function which takes pairs of elements (which will represent words along with the word following them in a “seed text”) and produces a Markov chain out of them.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMkvPairsInto ::</span> (<span class="dt">Hashable</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">MarkovI</span> a <span class="ot">-&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">MarkovI</span> a
insertMkvPairsInto mkv [] <span class="fu">=</span> mkv
insertMkvPairsInto mkv ps <span class="fu">=</span> insertEnd lst <span class="fu">$</span> foldl' (flip (uncurry (insertMkvI <span class="dv">1</span>))) mkv ps
  <span class="kw">where</span> lst <span class="fu">=</span> snd <span class="fu">$</span> last ps</code></pre>
<p>For each pair <code>(x, y)</code>, we insert a transition <code>x -&gt; y</code> with weight 1 into the Markov chain, and insert the final value in as an <code>End</code>. The reason this works is because of something I mentioned earlier: <code>Rand</code> handles distributions like <code>[(True, 1), (True, 1), (False, 1)]</code> properly. We build lists very similar to this one when processing a block of text for sentence generation, and when finally converting to <code>Markov</code>, all of that plumbing gets handled automatically. As a final note, we’ll use that <code>End</code> construct to mark the end of a sentence.</p>
<p>The next thing is actually building a <code>MarkovI</code> from a sentence – this can be done by zipping the list of its words with the tail of it and using the aforementioned function, like so:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="ot">wordPairs ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [(<span class="dt">T.Text</span>, <span class="dt">T.Text</span>)]
wordPairs <span class="fu">=</span> (zip <span class="fu">&lt;*&gt;</span> tail) <span class="fu">.</span> T.words

<span class="ot">insertSentence ::</span> <span class="dt">MarkovI</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">MarkovI</span> <span class="dt">T.Text</span>
insertSentence mkv <span class="fu">=</span> insertMkvPairsInto mkv <span class="fu">.</span> wordPairs</code></pre>
<p><small>wordPairs could be written more simply in a pointful style, but I think the point{free, less} version is cool. :)</small></p>
<p>Now, to build a Markov chain from a bunch of sentences (be it a paragraph, a book), we can just fold into an empty <code>MarkovI</code> and convert it from the intermediate representation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromSentences ::</span> <span class="dt">R.RandomGen</span> g <span class="ot">=&gt;</span> [<span class="dt">T.Text</span>] <span class="ot">-&gt;</span> <span class="dt">Markov</span> g <span class="dt">T.Text</span>
fromSentences <span class="fu">=</span> fromMarkovI <span class="fu">.</span> foldl' insertSentence M.empty</code></pre>
<p>The rest is mostly plumbing:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">System.Random.Mersenne.Pure64</span>

<span class="ot">runFromSentences ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">T.Text</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">T.Text</span>)
runFromSentences n sentences <span class="fu">=</span> <span class="kw">do</span>
  g <span class="ot">&lt;-</span> newPureMT
  <span class="kw">let</span> hds <span class="fu">=</span> map (head <span class="fu">.</span> T.words) sentences
  seed <span class="ot">&lt;-</span> R.uniform hds
  return <span class="fu">$</span> T.unwords <span class="fu">&lt;$&gt;</span> runMarkov n (fromSentences sentences) g seed

<span class="ot">test ::</span> [<span class="dt">T.Text</span>]
test <span class="fu">=</span> [
  <span class="st">&quot;I am a monster.&quot;</span>,
  <span class="st">&quot;I am a rock star.&quot;</span>,
  <span class="st">&quot;I want to go to Hawaii.&quot;</span>,
  <span class="st">&quot;I want to eat a hamburger.&quot;</span>,
  <span class="st">&quot;I have a really big headache.&quot;</span>,
  <span class="st">&quot;Haskell is a fun language!&quot;</span>,
  <span class="st">&quot;Go eat a big hamburger!&quot;</span>,
  <span class="st">&quot;Markov chains are fun to use!&quot;</span>
  ]</code></pre>
<p>We get a new <a href="http://hackage.haskell.org/package/mersenne-random-pure64-0.2.0.2/docs/System-Random-Mersenne-Pure64.html"><code>PureMT</code></a> to use for a generator, and grab a random word (from the beginning of a sentence) to use as the starting state. We then run a markov simulation, collecting the words we pass through, and finally call <code>T.unwords</code> on the result to build a sentence from the words in sequence. Running this yields some interesting statements (and a lot of nonsensical ones), for example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> runFromSentences <span class="dv">10</span> test
<span class="dt">Right</span> <span class="st">&quot;Haskell is a hamburger.&quot;</span>
<span class="dt">Right</span> <span class="st">&quot;Go eat a really big headache.&quot;</span>
<span class="dt">Right</span> <span class="st">&quot;I am a fun to go to go to eat&quot;</span></code></pre>
<h3 id="application-rap-candy">Application: Rap Candy</h3>
<p>As you might imagine, this type of thing gets more interesting when you’re working with a larger set of sentences. For me, I thought it would be fun(ny) to take lines from Eminem’s music as “sentences,” make tweet-sized snippets from them, and automate a twitter bot to post one every day. Most of the tweets are pretty nonsensical (and very vulgar), here’s one:</p>
<blockquote class="twitter-tweet" lang="en"><p>
Now I'm on a magazine
Take a catastrophe for me
Cause of New sh*t, exclusive whoo kid
I'm the first king of danger, intertwine it
</p>
— rapcandy (<span class="citation">@_rapcandy</span>) <a href="https://twitter.com/_rapcandy/statuses/495019304883331072">August 1, 2014</a>
</blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p><a href="https://github.com/5outh/rapcandy">rapcandy is open source</a>. Its Markov chain mechanism differs slightly from what was presented here, but the ideas are the same. It also includes a simple example of how to connect to Twitter using Haskell (which I’ll be covering separately in a short blog post soon), as well as web-scraper written in node that I used to download Eminem’s lyrics programmatically. Feel free to browse the code and follow <a href="https://twitter.com/_rapcandy">@_rapcandy on Twitter</a>.</p>
<p>I’ve also boxed up (most of) the code from this blog post into a small cabal package that you can use if you’d like to play around with your own Markov chain based applications. <a href="https://github.com/5outh/markov-sim">You can download markov-sim and browse its source here</a>.</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-08-04-markov-chains.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-07-21-molecule.html">An attempt at zipper-based type inference in Molecule</a>
	<p class="published">Published by Ben Kovach on July 21, 2014</p>
</div>
<div class="post_body">
	<h3 id="prelude">Prelude</h3>
<p>I recently designed a very small programming language, <a href="https://github.com/5outh/Molecule">Molecule</a>. Molecule is a slight extension of the <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus (STLC)</a> that supports type inference. It is mostly a contained experiment on how to implement type inference in an STLC-like language.</p>
<p>In this blog post, I want to talk about my experience with Molecule and its static type checking and inference mechanism, which works for <em>most</em> valid programs. I do not know if this approach can be modified to work for <em>all</em> valid programs (and indeed this is a problem), but I think it’s worth talking about regardless.</p>
<p>Molecule and its REPL, <code>mi</code>, can be downloaded <a href="https://github.com/5outh/Molecule">from GitHub</a>, if you’d like to play with it.</p>
<h3 id="syntax">Syntax</h3>
<p>Molecule’s syntax tries to emulate the mathematical notation used in the lambda calculus, without explicit type annotations (which aren’t even allowed syntactically). A valid program can be one of the following expressions (informally):</p>
<ul>
<li><code>Int</code> literals</li>
<li><code>Boolean</code> literals (<code>t</code> and <code>f</code>)</li>
<li>Addition (<code>1 + 2</code>)</li>
<li>Boolean Or (<code>f | t</code>)</li>
<li>Lambda abstractions (<code>\x. x + x</code>), and</li>
<li>Function application (<code>(\x.x) 80</code>)</li>
</ul>
<p>Expressions can have type <code>Int</code>, <code>Bool</code>, or any function type between types, e.g. <code>Int -&gt; Bool</code>. Expressions are monomorphic, meaning they cannot take more than one value. For a quick example, the polymorphic identity function <code>\x.x</code> has no type in Molecule – only applied to another expression can it take on a type. <code>(\x.x) 10</code>, for example, has type <code>Int</code>.</p>
<p>The type inference mechanism that I will be describing never produces the <em>wrong</em> type for a Molecule expression, but it fails to realize that some expressions can be typed at all. The following expression, for example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">((\x<span class="fu">.</span>x) (\x<span class="fu">.</span>x)) f</code></pre>
<p>should have type <code>Bool</code>; however, Molecule’s type checker cannot unify its type.</p>
<h3 id="type-inference-in-molecule">Type Inference in Molecule</h3>
<p>When designing a slightly more ambitious PL, I was writing a naïve type inferencer and hit the point where I was pattern matching on non-leaf expression constructors in order to determine the types of the leaves. At a basic level, there was an <code>Expr</code> data type akin to:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> 
    <span class="dt">Var</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">PInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:+:</span> <span class="dt">Expr</span>
   <span class="co">-- ... and so on</span></code></pre>
<p>And I was pattern matching against, for example <code>(Var &quot;x&quot; :+: a)</code> as well as <code>(a :+: Var &quot;x&quot;)</code> in order to determine that <code>x</code> was an <code>Int</code>. As you can imagine, this got tedious quickly. I wanted to be able to have some function <code>infer :: Expr -&gt; Type</code> such that <code>infer (Var x)</code> would spit out the type for <code>x</code> in the context of its expression. After narrowing down the information that I actually needed to typecheck a <code>Var</code>, I realized all that was needed in order to infer the type of an expression was information about where the <code>Var</code> came from one level higher in the AST. For example, in the expression <code>(Var &quot;x&quot; :+: a)</code>, just knowing that <code>Var &quot;x&quot;</code> came from a <code>:+:</code> expression is enough to determine that <code>x : Int</code>, and similarly for other types of expressions.</p>
<p>Let’s dive into the actual definitions of Molecule’s data types in order to talk about how this works concretely in practice.</p>
<p>Types are simple, as described above. <code>TLam</code> represents function types (<code>Int -&gt; Bool === TLam TInt TBool</code>).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MoleculeType</span> <span class="fu">=</span>
    <span class="dt">TBool</span>
  <span class="fu">|</span> <span class="dt">TInt</span>
  <span class="fu">|</span> <span class="dt">TLam</span> <span class="dt">MoleculeType</span> <span class="dt">MoleculeType</span>
    <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre>
<p>Values can be <code>Bool</code>s, <code>Int</code>s, or function values with an expression environment (mappings from variables in scope to expressions), the name of the argument it takes, and an expression body.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">MoleculeValue</span>

<span class="kw">data</span> <span class="dt">MoleculeValue</span> <span class="fu">=</span>
    <span class="dt">VBool</span> <span class="dt">Bool</span>
  <span class="fu">|</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VLam</span> <span class="dt">Env</span> <span class="dt">Name</span> <span class="dt">MoleculeExpr</span></code></pre>
<p>Expressions are represented as you might expect. <code>EAbs</code> represents a lambda abstraction, <code>EApp</code> function application, and <code>:+:</code> and <code>:|:</code> correspond to addition and boolean <code>or</code>, respectively.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MoleculeExpr</span> <span class="fu">=</span>
    <span class="dt">EVar</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">ETrue</span> 
  <span class="fu">|</span> <span class="dt">EFalse</span>
  <span class="fu">|</span> <span class="dt">EInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">EAbs</span> <span class="dt">Name</span> <span class="dt">MoleculeExpr</span>
  <span class="fu">|</span> <span class="dt">EApp</span> <span class="dt">MoleculeExpr</span> <span class="dt">MoleculeExpr</span>
  <span class="fu">|</span> <span class="dt">MoleculeExpr</span> <span class="fu">:+:</span> <span class="dt">MoleculeExpr</span>
  <span class="fu">|</span> <span class="dt">MoleculeExpr</span> <span class="fu">:|:</span> <span class="dt">MoleculeExpr</span>
    <span class="kw">deriving</span> <span class="dt">Eq</span> </code></pre>
<p>Here’s the key data type we need in order to keep track of the expression we’re coming from when we hit <code>Var</code> values in the type inferencer. Each of these <code>Crumb</code>s tag the expression one level higher and carry along all information in it that isn’t already present in the expression currently being expected. This is one of the pieces of a <a href="http://learnyouahaskell.com/zippers">zipper</a> for the Molecule AST.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MoleculeCrumb</span> <span class="fu">=</span>
  <span class="fu">|</span> <span class="dt">CPlus</span> <span class="dt">MoleculeExpr</span>   <span class="co">-- Came from +</span>
  <span class="fu">|</span> <span class="dt">COr</span> <span class="dt">MoleculeExpr</span>     <span class="co">-- Came from |</span>
  <span class="fu">|</span> <span class="dt">CAbs</span> <span class="dt">Name</span>            <span class="co">-- Came from a lambda abstraction</span>
  <span class="fu">|</span> <span class="dt">CApp1</span> <span class="dt">MoleculeExpr</span>   <span class="co">-- Came from first arg of application</span>
  <span class="fu">|</span> <span class="dt">CApp2</span> <span class="dt">MoleculeExpr</span>   <span class="co">-- Came from second arg of application</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<p>We use a basic monad transformer stack to represent the type of the type checker.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TypeEnv</span>     <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Name</span> <span class="dt">MoleculeType</span>
<span class="kw">type</span> <span class="dt">Scope</span>       <span class="fu">=</span> <span class="dt">S.Set</span> <span class="dt">Name</span>
<span class="kw">type</span> <span class="dt">Typechecker</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">MoleculeError</span> (<span class="dt">ReaderT</span> (<span class="dt">Maybe</span> <span class="dt">MoleculeCrumb</span>, <span class="dt">Scope</span>) (<span class="dt">StateT</span> <span class="dt">TypeEnv</span> <span class="dt">Identity</span>))</code></pre>
<p><code>TypeEnv</code>s are maps from variable names to types, and a <code>Scope</code> is a list of variable names in scope. The typechecker has access to 3 basic (monadic) effects:</p>
<ol style="list-style-type: decimal">
<li>Error production, via <code>ExceptT MoleculeError</code></li>
<li>Threading variable scope and a crumb through the computation, via <code>ReaderT (Maybe MoleculeCrumb, Scope)</code>, and</li>
<li>Access to a mutable type environment, via <code>StateT TypeEnv Identity</code>.</li>
</ol>
<p>Note that we don’t need a “full” zipper here, since we only care about the <em>single</em> expression that the variable came from, not the entire path from the AST root. This is all we need to implement a relatively robust type inference/checking mechanism for Molecule. The <em>inference</em> part of type checking takes place in the following branch of the <code>check</code> function, which accepts an <code>EVar</code> (Note: this is modified for brevity; in practice, more specific type errors are thrown for failing expressions).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">check ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Typechecker</span> <span class="dt">MoleculeType</span>
check (<span class="dt">EVar</span> name) <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> addBinding name typ <span class="fu">=</span> modify (M.insert name typ) <span class="fu">&gt;&gt;</span> return typ
      typeError <span class="fu">=</span> throwError <span class="fu">.</span> <span class="dt">TypeError</span>
  (crumb, scope) <span class="ot">&lt;-</span> ask
  <span class="kw">if</span> S.notMember name scope
  <span class="kw">then</span> typeError <span class="fu">$</span> <span class="st">&quot;variable not in scope: &quot;</span> <span class="fu">++</span> name
  <span class="kw">else</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> get
    <span class="kw">case</span> M.lookup name env <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> crumb <span class="kw">of</span>
        <span class="dt">Just</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>
          <span class="dt">CPlus</span> _ <span class="ot">-&gt;</span> addBinding name <span class="dt">TInt</span>
          <span class="dt">COr</span>   _ <span class="ot">-&gt;</span> addBinding name <span class="dt">TBool</span>
          <span class="dt">CAbs</span> nm <span class="ot">-&gt;</span> <span class="kw">case</span> M.lookup nm env <span class="kw">of</span>
            <span class="dt">Just</span> t  <span class="ot">-&gt;</span> addBinding name t
          <span class="dt">CApp2</span> e <span class="ot">-&gt;</span> <span class="kw">do</span>
            t <span class="ot">&lt;-</span> check e
            <span class="kw">case</span> t <span class="kw">of</span>
              <span class="dt">TLam</span> v _ <span class="ot">-&gt;</span> addBinding name v
      <span class="dt">Just</span> t <span class="ot">-&gt;</span> <span class="kw">case</span> crumb <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return t
        <span class="dt">Just</span> cb <span class="ot">-&gt;</span> <span class="kw">case</span> cb <span class="kw">of</span>
          <span class="dt">CPlus</span> _ <span class="fu">|</span> t <span class="fu">==</span> <span class="dt">TInt</span>  <span class="ot">-&gt;</span> return <span class="dt">TInt</span>
          <span class="dt">COr</span>   _ <span class="fu">|</span> t <span class="fu">==</span> <span class="dt">TBool</span> <span class="ot">-&gt;</span> return <span class="dt">TBool</span>
          <span class="dt">CAbs</span> _ <span class="ot">-&gt;</span> return t
          <span class="dt">CApp1</span> _ <span class="ot">-&gt;</span> <span class="kw">case</span> t <span class="kw">of</span>
            <span class="dt">TLam</span> _ _ <span class="ot">-&gt;</span> return t
          <span class="dt">CApp2</span> e <span class="ot">-&gt;</span> <span class="kw">do</span>
            t' <span class="ot">&lt;-</span> check e
            <span class="kw">case</span> t' <span class="kw">of</span>
              <span class="dt">TLam</span> typ _ <span class="fu">|</span> typ <span class="fu">==</span> t <span class="ot">-&gt;</span> return t</code></pre>
<p>That’s a bit of a mouthful, but can be broken up into sections. First off, if we hit this block of code, we’ve hit a variable in a program and need to unify its type. We first get the crumb and scope that has been accumulating throughout traversal of the AST. We then check if the variable in question is in scope; if not, we throw a <code>TypeError</code>. We next get the type environment <code>env</code>. If the variable in question is not bound in the type environment, we bind it to the appropriate type and return it using <code>addBinding</code>. If we came from a lambda abstraction, the (sub)expression must be <code>\x.x</code>, so we return the type of <code>x</code> in the environment, if it already exists. If we came from the second value of an application (i.e. the value being <em>applied</em> to a function), we check the type of the function it is being applied to – if it isn’t a lambda abstraction, the typechecker fails.</p>
<p>It’s worth noting that this last <code>CApp2</code> rule is exactly <em>why</em> the expression I noted earlier – <code>((\x.x) (\y.y)) 10</code> – fails. The subexpression <code>((\x.x) (\y.y))</code> doesn’t typecheck to a <code>TLam</code>; it fails to typecheck because <code>\y.y</code> isn’t unifiable. But I digress – the typechecker works reasonably well and I think the schema is simple enough to be interesting, even if not exactly practical/suitable for real-world usage in its current state.</p>
<p>If there exists a binding in the type environment for the variable in question, we just make sure that type matches what we expect and return it.</p>
<p>The rest of the <code>check</code> function consists of functions in the same vein as this one (the <code>:+:</code> branch, again omitting error-handling noise):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withCrumb ::</span> <span class="dt">Typechecker</span> a <span class="ot">-&gt;</span> <span class="dt">MoleculeCrumb</span> <span class="ot">-&gt;</span> <span class="dt">Typechecker</span> a
withCrumb action crumb <span class="fu">=</span> local (_1 <span class="fu">.~</span> <span class="dt">Just</span> crumb) action

check (e1 <span class="fu">:+:</span> e2) <span class="fu">=</span> <span class="kw">do</span>
  e1' <span class="ot">&lt;-</span> check e1 <span class="ot">`withCrumb`</span> <span class="dt">CPlus</span> e2
  e2' <span class="ot">&lt;-</span> check e2 <span class="ot">`withCrumb`</span> <span class="dt">CPlus</span> e1
  <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
    (<span class="dt">TInt</span>, <span class="dt">TInt</span>) <span class="ot">-&gt;</span> return <span class="dt">TInt</span></code></pre>
<p>where we set the <code>Crumb</code> in the expression with a helper function <code>withCrumb</code> (which makes use of the <code>local</code> and a common <code>lens</code>/operation) and propagate typechecking through the rest of the AST.</p>
<p>We can run the typechecker using the final function <code>typecheck</code> (which looks complex but just runs a typechecking operation with initially empty environments and no crumb):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">typecheck ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">MoleculeError</span> <span class="dt">MoleculeType</span>
typecheck <span class="fu">=</span> runTypecheck <span class="dt">Nothing</span> S.empty M.empty
  <span class="kw">where</span> runTypecheck crumb scope te expr <span class="fu">=</span> 
    runIdentity <span class="fu">$</span> evalStateT (runReaderT (runExceptT (check expr)) (crumb, scope)) te</code></pre>
<p>Now we have a static typechecker for Molecule expressions, which means, most importantly, that we can run expressions safely <em>without the types</em>, which in turn removes a lot of ambiguity from the actual evaluator and allows for faster evaluation since expressions need not be typechecked at runtime.</p>
<h3 id="evaluating-molecule-expressions">Evaluating Molecule Expressions</h3>
<p>Let’s get right to it – the code for evaluation in Molecule looks like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Evaluator</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">MoleculeError</span> (<span class="dt">Reader</span> (<span class="dt">M.Map</span> <span class="dt">Name</span> <span class="dt">MoleculeValue</span>))

<span class="ot">eval ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Evaluator</span> <span class="dt">MoleculeValue</span>
eval e <span class="fu">=</span> <span class="kw">do</span>
  env <span class="ot">&lt;-</span> ask
  <span class="kw">case</span> e <span class="kw">of</span>
    <span class="dt">ETrue</span>   <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VBool</span> <span class="dt">True</span>
    <span class="dt">EFalse</span>  <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VBool</span> <span class="dt">False</span>
    <span class="dt">EInt</span> x  <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VInt</span> x
    <span class="dt">EAbs</span> name e1 <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VLam</span> env name e1
    <span class="dt">EVar</span> nm <span class="ot">-&gt;</span> return <span class="fu">$</span> fromJust (M.lookup nm env) 
    e1 <span class="fu">:+:</span> e2 <span class="ot">-&gt;</span> <span class="kw">do</span>
      [a, b] <span class="ot">&lt;-</span> mapM eval [e1, e2]
      <span class="kw">case</span> (a, b) <span class="kw">of</span>
        (<span class="dt">VInt</span> a', <span class="dt">VInt</span> b') <span class="ot">-&gt;</span> return <span class="fu">.</span> <span class="dt">VInt</span> <span class="fu">$</span> a' <span class="fu">+</span> b'
    <span class="dt">EApp</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span>
      [e1', e2'] <span class="fu">=</span> mapM eval [e1, e2]
      <span class="kw">case</span> e1' <span class="kw">of</span>
        <span class="dt">VLam</span> env' name body <span class="ot">-&gt;</span> local (const <span class="fu">$</span> M.insert name e2' env') <span class="fu">$</span> eval body</code></pre>
<p>I’ve removed the <code>:|:</code> rule for brevity (hint: it looks just like <code>:+:</code>). Most of this is pretty straightforward because we don’t have to deal with typechecking at runtime. The most complex evaluation rule is the one for <code>EApp</code>, which applies <code>e2</code> to <code>e1</code>. This rule says to evaluate <code>e1</code> and <code>e2</code>, then take the resulting lambda abstraction, bind the argument name to <code>e2</code>’s evaluated expression, then evaluate the lambda abstraction’s body with the modified environment.</p>
<p>Again, we can run the evaluator with a simple wrapper function <code>evaluate</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">MoleculeError</span> <span class="dt">MoleculeValue</span>
evaluate <span class="fu">=</span> runEval M.empty
  <span class="kw">where</span> runEval env e <span class="fu">=</span> runReader (runExceptT (eval e)) env</code></pre>
<p>…and that’s basically all there is to Molecule! The <code>mi</code> REPL is built with <a href="https://hackage.haskell.org/package/haskeline">haskeline</a> and supports type checking via <code>:t</code> (a la <code>ghci</code>) and evaluation by simply typing (no pun intended) expressions.</p>
<p>I’ve still got a long way to go in the programming languages world, but I’m proud of Molecule even if its type inference is a little flawed. My next project will either have a type system closer to <a href="http://en.wikipedia.org/wiki/Hindley–Milner_type_system">Hindley Milner</a> (so I can type infer with something closer to <a href="http://en.wikipedia.org/wiki/Hindley–Milner_type_system#Algorithm_W">Algorithm W</a>), or just make type annotations explicit (for a different set of challenges).</p>
<p>Again, Molecule’s full source code is <a href="https://github.com/5outh/Molecule">available on GitHub</a>.</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-07-21-molecule.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-04-30-hylomorphisms-and-treesort.html">Hylomorphisms and treesort</a>
	<p class="published">Published by Ben Kovach on April 30, 2014</p>
</div>
<div class="post_body">
	<p>Consider the following data structure, representing a binary search tree:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span>  <span class="dt">BST</span> a <span class="fu">=</span> 
    <span class="dt">Tree</span> (<span class="dt">BST</span> a) a (<span class="dt">BST</span> a)
  <span class="fu">|</span> <span class="dt">Empty</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre>
<p>As it turns out, this data structure provides a nice way to introduce the concepts of different types of morphisms used all over the place in Haskell - the fold, or “catamorphism”, the unfold, or “anamorphism”, and compositions of the two, the “hylomorphism” and “metamorphism.”</p>
<p>The bracket notations that I’ll use below come from Meijer, Fokkinga and Patterson’s excellent paper <a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a>. If you enjoy the article, I’d suggest giving it a look!</p>
<p>I’m writing this because I recall encountering these names when learning Haskell early on and being very confused, particularly by the latter two types. Folds (and to a lesser extent, unfolds) are commonplace in Haskell. Hylo- and metamorphisms are also pretty common, but they’re not as easy to spot. From <a href="http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)">Wikipedia</a>:</p>
<blockquote>
<p>In computer science, and in particular functional programming, a hylomorphism is a recursive function, corresponding to the composition of an anamorphism (which first builds a set of results; also known as ‘unfolding’) and a catamorphism (which then folds these results into a final return value)</p>
</blockquote>
<p>The canonical example of a hylomorphism is the factorial function, which (usually) implicitly composes functions. The goal of this post is to lay out an <strong>explicit</strong> example of a hylo- (and meta-) morphism in a natural way. We’ll start with a couple of functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a
insert x <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Empty</span> x <span class="dt">Empty</span>
insert x (<span class="dt">Tree</span> left a right)
  <span class="fu">|</span> x <span class="fu">&lt;</span> a     <span class="fu">=</span> <span class="dt">Tree</span> (treeInsert x left) a right
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Tree</span> left a (treeInsert x right)

<span class="ot">fromList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BST</span> a
fromList xs <span class="fu">=</span> foldr treeInsert <span class="dt">Empty</span> xs</code></pre>
<p>We have an insertion function and our first example of a catamorphism, <code>fromList</code>! We’re folding all values from a list into a new structure (a <code>BST</code>) and destroying the list in the process. This function can be written in so called “banana brackets,” like so: <span class="math">\(fromList = (\!\left|treeInsert\right|\!)\)</span>.</p>
<p>I<code>fromList</code> can also be considered an anamorphism. Catamorphisms destroy structures to build final values, whereas anamorphisms take an initial seed value and build a new structure from it. In <code>fromList</code>, <code>xs</code> can be considered a “seed” value to build a <code>BST a</code> from, making <code>fromList</code> a perfectly valid anamorphism as well. As such, <code>fromList</code> can also be written in “lens brackets”: <span class="math">\(fromList = [\!(treeInsert)\!]\)</span>.</p>
<p>We can also define a new pair of cata/anamorphisms by folding the tree into a list:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldTree ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> b
foldTree f b <span class="dt">Empty</span> <span class="fu">=</span> b
foldTree f b (<span class="dt">Tree</span> left a right) <span class="fu">=</span> foldTree f ( f a (foldTree f b right) ) left

<span class="ot">toList ::</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> [a]
toList t <span class="fu">=</span> foldTree (<span class="fu">:</span>) [] t</code></pre>
<p><code>foldTree</code> is analogous to <code>foldr</code> (and would be a fine definition for <code>foldr</code> in a <code>Foldable</code> instance), and <code>toList</code> destructs (folds) a <code>BST a</code> into an <code>[a]</code>. Thinking this way, <code>toList</code> again defines a catamorphism, this time from <code>BST a -&gt; [a]</code>, denoted <span class="math">\(toList = (\!\left| : \right|\!)\)</span>. But we can also think of <code>toList</code> as unfolding a <code>BST a</code> into an <code>[a]</code>, so we can analogously define an anamorphism <span class="math">\(toList = [\!( : )\!]\)</span>.</p>
<p>There’s something interesting about <code>toList</code>: <code>foldTree</code> traverses a <code>BST</code> in order, so it actually produces a sorted list (given that elements are <code>insert</code>ed rather than randomly placed!). Now we have a way to construct a binary search tree from a list of elements, and destruct a binary search tree into a sorted list of elements. This gives rise to a simple definion of a sorting algorithm, namely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treesort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
treesort <span class="fu">=</span> toList <span class="fu">.</span> fromList</code></pre>
<p>Because <code>toList</code> and <code>fromList</code> are both cata- and anamorphims, <code>treesort</code> actually defines a hylomorphism <em>and</em> a metamorphism.</p>
<p>As we noted before, a hylomorphism is defined as the composition of an anamorphism (unfold) with a catamorphism (fold). If we think of <code>fromList</code> as an anamorphism and <code>toList</code> as a catamorphism, we have constructed a hylomorphism directly. Namely, the function <span class="math">\(treesort = [\![([], (:)),(insert, null)]\!]\)</span> (the brackets here are commonly called “envelopes”). <code>null</code> isn’t explicit in the definition of <code>treesort</code> (instead, it’s implicit in <code>foldr</code>), but it describes a terminating condition for <code>fromList</code>. Similarly, <code>[]</code> is just the container to fold values into.</p>
<p>We can once again think of this function in the opposite manner by thinking of <code>fromList</code> as a catamorphism and <code>toList</code> as an anamorphism, giving rise to a metamorphism, defined by composition in the opposite direction. Metamorphisms (as far as I know) have no bracket notation in literature, but I want to mention that we do have a name for such things. My guess is that any metamorphism can actually be thought of as a hylomorphism, since the objects being operated on must be both foldable and unfoldable, but I don’t know for sure.</p>
<p>Finally, note that we can also create another function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">what ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a
what <span class="fu">=</span> fromList <span class="fu">.</span> toList</code></pre>
<p>which is also a hylo- and metamorphism. However, this isn’t very useful (in fact, one might consider it counterproductive), but I’ll leave it as an exercise to the reader to figure out why.</p>
<p>Thanks for reading!</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-04-30-hylomorphisms-and-treesort.html#disqus_thread"></a>
    	</li>
    
</ul></p>
      </section>
      <footer>
      </footer>
    </div>
    <script src="js/scale.fix.js"></script>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-53651640-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
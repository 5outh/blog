<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" style="position:relative;">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Abstract Nonsense - Ramblings</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/syntax.css" />
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
        <script src="./js/Utils.js"></script>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <link href="http://fonts.googleapis.com/css?family=Alegreya+Sans+SC|Della+Respira|Montaga" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Roboto:400,100" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
        <script type="text/javascript">

        </script>
    </head>
    <body id="main">
      <div class="wrapper">
        <div id="header">
            <div id="logo">
                <a href="./" id="main_title">Abstract Nonsense</a>
                <p id="main_subtitle"><br /><a href="./">By Benjamin Kovach</a></p>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./projects.html">Projects</a>
                <a href="./contact.html">About</a>
                <a href="./cv.html">CV</a>
                <a href="./archive.html">Archive</a>
                <a href="./atom.xml">Atom</a>
            </div>
        </div>
        <div id="content">
            <center>
                
                
                
                    </center>
            <div id="main_body">
                <ul class="blog_list">
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-07-21-molecule.html">An attempt at zipper-based type inference in Molecule</a>
	<p class="published">Published by Ben Kovach on July 21, 2014</p>
</div>
<div class="post_body">
	<h3 id="prelude">Prelude</h3>
<p>I recently designed a very small programming language, <a href="https://github.com/5outh/Molecule">Molecule</a>. Molecule is a slight extension of the <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus (STLC)</a> that supports type inference. It is mostly a contained experiment on how to implement type inference in an STLC-like language.</p>
<p>In this blog post, I want to talk about my experience with Molecule and its static type checking and inference mechanism, which works for <em>most</em> valid programs. I do not know if this approach can be modified to work for <em>all</em> valid programs (and indeed this is a problem), but I think it’s worth talking about regardless.</p>
<p>Molecule and its REPL, <code>mi</code>, can be downloaded <a href="https://github.com/5outh/Molecule">from GitHub</a>, if you’d like to play with it.</p>
<h3 id="syntax">Syntax</h3>
<p>Molecule’s syntax tries to emulate the mathematical notation used in the lambda calculus, without explicit type annotations (which aren’t even allowed syntactically). A valid program can be one of the following expressions (informally):</p>
<ul>
<li><code>Int</code> literals</li>
<li><code>Boolean</code> literals (<code>t</code> and <code>f</code>)</li>
<li>Addition (<code>1 + 2</code>)</li>
<li>Boolean Or (<code>f | t</code>)</li>
<li>Lambda abstractions (<code>\x. x + x</code>), and</li>
<li>Function application (<code>(\x.x) 80</code>)</li>
</ul>
<p>Expressions can have type <code>Int</code>, <code>Bool</code>, or any function type between types, e.g. <code>Int -&gt; Bool</code>. Expressions are monomorphic, meaning they cannot take more than one value. For a quick example, the polymorphic identity function <code>\x.x</code> has no type in Molecule – only applied to another expression can it take on a type. <code>(\x.x) 10</code>, for example, has type <code>Int</code>.</p>
<p>The type inference mechanism that I will be describing never produces the <em>wrong</em> type for a Molecule expression, but it fails to realize that some expressions can be typed at all. The following expression, for example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">((\x<span class="fu">.</span>x) (\x<span class="fu">.</span>x)) f</code></pre>
<p>should have type <code>Bool</code>; however, Molecule’s type checker cannot unify its type.</p>
<h3 id="type-inference-in-molecule">Type Inference in Molecule</h3>
<p>When designing a slightly more ambitious PL, I was writing a naïve type inferencer and hit the point where I was pattern matching on non-leaf expression constructors in order to determine the types of the leaves. At a basic level, there was an <code>Expr</code> data type akin to:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> 
    <span class="dt">Var</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">PInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:+:</span> <span class="dt">Expr</span>
   <span class="co">-- ... and so on</span></code></pre>
<p>And I was pattern matching against, for example <code>(Var &quot;x&quot; :+: a)</code> as well as <code>(a :+: Var &quot;x&quot;)</code> in order to determine that <code>x</code> was an <code>Int</code>. As you can imagine, this got tedious quickly. I wanted to be able to have some function <code>infer :: Expr -&gt; Type</code> such that <code>infer (Var x)</code> would spit out the type for <code>x</code> in the context of its expression. After narrowing down the information that I actually needed to typecheck a <code>Var</code>, I realized all that was needed in order to infer the type of an expression was information about where the <code>Var</code> came from one level higher in the AST. For example, in the expression <code>(Var &quot;x&quot; :+: a)</code>, just knowing that <code>Var &quot;x&quot;</code> came from a <code>:+:</code> expression is enough to determine that <code>x : Int</code>, and similarly for other types of expressions.</p>
<p>Let’s dive into the actual definitions of Molecule’s data types in order to talk about how this works concretely in practice.</p>
<p>Types are simple, as described above. <code>TLam</code> represents function types (<code>Int -&gt; Bool === TLam TInt TBool</code>).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MoleculeType</span> <span class="fu">=</span>
    <span class="dt">TBool</span>
  <span class="fu">|</span> <span class="dt">TInt</span>
  <span class="fu">|</span> <span class="dt">TLam</span> <span class="dt">MoleculeType</span> <span class="dt">MoleculeType</span>
    <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre>
<p>Values can be <code>Bool</code>s, <code>Int</code>s, or function values with an expression environment (mappings from variables in scope to expressions), the name of the argument it takes, and an expression body.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">MoleculeValue</span>

<span class="kw">data</span> <span class="dt">MoleculeValue</span> <span class="fu">=</span>
    <span class="dt">VBool</span> <span class="dt">Bool</span>
  <span class="fu">|</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VLam</span> <span class="dt">Env</span> <span class="dt">Name</span> <span class="dt">MoleculeExpr</span></code></pre>
<p>Expressions are represented as you might expect. <code>EAbs</code> represents a lambda abstraction, <code>EApp</code> function application, and <code>:+:</code> and <code>:|:</code> correspond to addition and boolean <code>or</code>, respectively.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MoleculeExpr</span> <span class="fu">=</span>
    <span class="dt">EVar</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">ETrue</span> 
  <span class="fu">|</span> <span class="dt">EFalse</span>
  <span class="fu">|</span> <span class="dt">EInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">EAbs</span> <span class="dt">Name</span> <span class="dt">MoleculeExpr</span>
  <span class="fu">|</span> <span class="dt">EApp</span> <span class="dt">MoleculeExpr</span> <span class="dt">MoleculeExpr</span>
  <span class="fu">|</span> <span class="dt">MoleculeExpr</span> <span class="fu">:+:</span> <span class="dt">MoleculeExpr</span>
  <span class="fu">|</span> <span class="dt">MoleculeExpr</span> <span class="fu">:|:</span> <span class="dt">MoleculeExpr</span>
    <span class="kw">deriving</span> <span class="dt">Eq</span> </code></pre>
<p>Here’s the key data type we need in order to keep track of the expression we’re coming from when we hit <code>Var</code> values in the type inferencer. Each of these <code>Crumb</code>s tag the expression one level higher and carry along all information in it that isn’t already present in the expression currently being expected. This is one of the pieces of a <a href="http://learnyouahaskell.com/zippers">zipper</a> for the Molecule AST.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MoleculeCrumb</span> <span class="fu">=</span>
  <span class="fu">|</span> <span class="dt">CPlus</span> <span class="dt">MoleculeExpr</span>   <span class="co">-- Came from +</span>
  <span class="fu">|</span> <span class="dt">COr</span> <span class="dt">MoleculeExpr</span>     <span class="co">-- Came from |</span>
  <span class="fu">|</span> <span class="dt">CAbs</span> <span class="dt">Name</span>            <span class="co">-- Came from a lambda abstraction</span>
  <span class="fu">|</span> <span class="dt">CApp1</span> <span class="dt">MoleculeExpr</span>   <span class="co">-- Came from first arg of application</span>
  <span class="fu">|</span> <span class="dt">CApp2</span> <span class="dt">MoleculeExpr</span>   <span class="co">-- Came from second arg of application</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<p>We use a basic monad transformer stack to represent the type of the type checker.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TypeEnv</span>     <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Name</span> <span class="dt">MoleculeType</span>
<span class="kw">type</span> <span class="dt">Scope</span>       <span class="fu">=</span> <span class="dt">S.Set</span> <span class="dt">Name</span>
<span class="kw">type</span> <span class="dt">Typechecker</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">MoleculeError</span> (<span class="dt">ReaderT</span> (<span class="dt">Maybe</span> <span class="dt">MoleculeCrumb</span>, <span class="dt">Scope</span>) (<span class="dt">StateT</span> <span class="dt">TypeEnv</span> <span class="dt">Identity</span>))</code></pre>
<p><code>TypeEnv</code>s are maps from variable names to types, and a <code>Scope</code> is a list of variable names in scope. The typechecker has access to 3 basic (monadic) effects:</p>
<ol style="list-style-type: decimal">
<li>Error production, via <code>ExceptT MoleculeError</code></li>
<li>Threading variable scope and a crumb through the computation, via <code>ReaderT (Maybe MoleculeCrumb, Scope)</code>, and</li>
<li>Access to a mutable type environment, via <code>StateT TypeEnv Identity</code>.</li>
</ol>
<p>Note that we don’t need a “full” zipper here, since we only care about the <em>single</em> expression that the variable came from, not the entire path from the AST root. This is all we need to implement a relatively robust type inference/checking mechanism for Molecule. The <em>inference</em> part of type checking takes place in the following branch of the <code>check</code> function, which accepts an <code>EVar</code> (Note: this is modified for brevity; in practice, more specific type errors are thrown for failing expressions).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">check ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Typechecker</span> <span class="dt">MoleculeType</span>
check (<span class="dt">EVar</span> name) <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> addBinding name typ <span class="fu">=</span> modify (M.insert name typ) <span class="fu">&gt;&gt;</span> return typ
      typeError <span class="fu">=</span> throwError <span class="fu">.</span> <span class="dt">TypeError</span>
  (crumb, scope) <span class="ot">&lt;-</span> ask
  <span class="kw">if</span> S.notMember name scope
  <span class="kw">then</span> typeError <span class="fu">$</span> <span class="st">&quot;variable not in scope: &quot;</span> <span class="fu">++</span> name
  <span class="kw">else</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> get
    <span class="kw">case</span> M.lookup name env <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> crumb <span class="kw">of</span>
        <span class="dt">Just</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>
          <span class="dt">CPlus</span> _ <span class="ot">-&gt;</span> addBinding name <span class="dt">TInt</span>
          <span class="dt">COr</span>   _ <span class="ot">-&gt;</span> addBinding name <span class="dt">TBool</span>
          <span class="dt">CAbs</span> nm <span class="ot">-&gt;</span> <span class="kw">case</span> M.lookup nm env <span class="kw">of</span>
            <span class="dt">Just</span> t  <span class="ot">-&gt;</span> addBinding name t
          <span class="dt">CApp2</span> e <span class="ot">-&gt;</span> <span class="kw">do</span>
            t <span class="ot">&lt;-</span> check e
            <span class="kw">case</span> t <span class="kw">of</span>
              <span class="dt">TLam</span> v _ <span class="ot">-&gt;</span> addBinding name v
      <span class="dt">Just</span> t <span class="ot">-&gt;</span> <span class="kw">case</span> crumb <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return t
        <span class="dt">Just</span> cb <span class="ot">-&gt;</span> <span class="kw">case</span> cb <span class="kw">of</span>
          <span class="dt">CPlus</span> _ <span class="fu">|</span> t <span class="fu">==</span> <span class="dt">TInt</span>  <span class="ot">-&gt;</span> return <span class="dt">TInt</span>
          <span class="dt">COr</span>   _ <span class="fu">|</span> t <span class="fu">==</span> <span class="dt">TBool</span> <span class="ot">-&gt;</span> return <span class="dt">TBool</span>
          <span class="dt">CAbs</span> _ <span class="ot">-&gt;</span> return t
          <span class="dt">CApp1</span> _ <span class="ot">-&gt;</span> <span class="kw">case</span> t <span class="kw">of</span>
            <span class="dt">TLam</span> _ _ <span class="ot">-&gt;</span> return t
          <span class="dt">CApp2</span> e <span class="ot">-&gt;</span> <span class="kw">do</span>
            t' <span class="ot">&lt;-</span> check e
            <span class="kw">case</span> t' <span class="kw">of</span>
              <span class="dt">TLam</span> typ _ <span class="fu">|</span> typ <span class="fu">==</span> t <span class="ot">-&gt;</span> return t</code></pre>
<p>That’s a bit of a mouthful, but can be broken up into sections. First off, if we hit this block of code, we’ve hit a variable in a program and need to unify its type. We first get the crumb and scope that has been accumulating throughout traversal of the AST. We then check if the variable in question is in scope; if not, we throw a <code>TypeError</code>. We next get the type environment <code>env</code>. If the variable in question is not bound in the type environment, we bind it to the appropriate type and return it using <code>addBinding</code>. If we came from a lambda abstraction, the (sub)expression must be <code>\x.x</code>, so we return the type of <code>x</code> in the environment, if it already exists. If we came from the second value of an application (i.e. the value being <em>applied</em> to a function), we check the type of the function it is being applied to – if it isn’t a lambda abstraction, the typechecker fails.</p>
<p>It’s worth noting that this last <code>CApp2</code> rule is exactly <em>why</em> the expression I noted earlier – <code>((\x.x) (\y.y)) 10</code> – fails. The subexpression <code>((\x.x) (\y.y))</code> doesn’t typecheck to a <code>TLam</code>; it fails to typecheck because <code>\y.y</code> isn’t unifiable. But I digress – the typechecker works reasonably well and I think the schema is simple enough to be interesting, even if not exactly practical/suitable for real-world usage in its current state.</p>
<p>If there exists a binding in the type environment for the variable in question, we just make sure that type matches what we expect and return it.</p>
<p>The rest of the <code>check</code> function consists of functions in the same vein as this one (the <code>:+:</code> branch, again omitting error-handling noise):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withCrumb ::</span> <span class="dt">Typechecker</span> a <span class="ot">-&gt;</span> <span class="dt">MoleculeCrumb</span> <span class="ot">-&gt;</span> <span class="dt">Typechecker</span> a
withCrumb action crumb <span class="fu">=</span> local (_1 <span class="fu">.~</span> <span class="dt">Just</span> crumb) action

check (e1 <span class="fu">:+:</span> e2) <span class="fu">=</span> <span class="kw">do</span>
  e1' <span class="ot">&lt;-</span> check e1 <span class="ot">`withCrumb`</span> <span class="dt">CPlus</span> e2
  e2' <span class="ot">&lt;-</span> check e2 <span class="ot">`withCrumb`</span> <span class="dt">CPlus</span> e1
  <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
    (<span class="dt">TInt</span>, <span class="dt">TInt</span>) <span class="ot">-&gt;</span> return <span class="dt">TInt</span></code></pre>
<p>where we set the <code>Crumb</code> in the expression with a helper function <code>withCrumb</code> (which makes use of the <code>local</code> and a common <code>lens</code>/operation) and propagate typechecking through the rest of the AST.</p>
<p>We can run the typechecker using the final function <code>typecheck</code> (which looks complex but just runs a typechecking operation with initially empty environments and no crumb):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">typecheck ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">MoleculeError</span> <span class="dt">MoleculeType</span>
typecheck <span class="fu">=</span> runTypecheck <span class="dt">Nothing</span> S.empty M.empty
  <span class="kw">where</span> runTypecheck crumb scope te expr <span class="fu">=</span> 
    runIdentity <span class="fu">$</span> evalStateT (runReaderT (runExceptT (check expr)) (crumb, scope)) te</code></pre>
<p>Now we have a static typechecker for Molecule expressions, which means, most importantly, that we can run expressions safely <em>without the types</em>, which in turn removes a lot of ambiguity from the actual evaluator and allows for faster evaluation since expressions need not be typechecked at runtime.</p>
<h3 id="evaluating-molecule-expressions">Evaluating Molecule Expressions</h3>
<p>Let’s get right to it – the code for evaluation in Molecule looks like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Evaluator</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">MoleculeError</span> (<span class="dt">Reader</span> (<span class="dt">M.Map</span> <span class="dt">Name</span> <span class="dt">MoleculeValue</span>))

<span class="ot">eval ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Evaluator</span> <span class="dt">MoleculeValue</span>
eval e <span class="fu">=</span> <span class="kw">do</span>
  env <span class="ot">&lt;-</span> ask
  <span class="kw">case</span> e <span class="kw">of</span>
    <span class="dt">ETrue</span>   <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VBool</span> <span class="dt">True</span>
    <span class="dt">EFalse</span>  <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VBool</span> <span class="dt">False</span>
    <span class="dt">EInt</span> x  <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VInt</span> x
    <span class="dt">EAbs</span> name e1 <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VLam</span> env name e1
    <span class="dt">EVar</span> nm <span class="ot">-&gt;</span> return <span class="fu">$</span> fromJust (M.lookup nm env) 
    e1 <span class="fu">:+:</span> e2 <span class="ot">-&gt;</span> <span class="kw">do</span>
      [a, b] <span class="ot">&lt;-</span> mapM eval [e1, e2]
      <span class="kw">case</span> (a, b) <span class="kw">of</span>
        (<span class="dt">VInt</span> a', <span class="dt">VInt</span> b') <span class="ot">-&gt;</span> return <span class="fu">.</span> <span class="dt">VInt</span> <span class="fu">$</span> a' <span class="fu">+</span> b'
    <span class="dt">EApp</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span>
      [e1', e2'] <span class="fu">=</span> mapM eval [e1, e2]
      <span class="kw">case</span> e1' <span class="kw">of</span>
        <span class="dt">VLam</span> env' name body <span class="ot">-&gt;</span> local (const <span class="fu">$</span> M.insert name e2' env') <span class="fu">$</span> eval body</code></pre>
<p>I’ve removed the <code>:|:</code> rule for brevity (hint: it looks just like <code>:+:</code>). Most of this is pretty straightforward because we don’t have to deal with typechecking at runtime. The most complex evaluation rule is the one for <code>EApp</code>, which applies <code>e2</code> to <code>e1</code>. This rule says to evaluate <code>e1</code> and <code>e2</code>, then take the resulting lambda abstraction, bind the argument name to <code>e2</code>’s evaluated expression, then evaluate the lambda abstraction’s body with the modified environment.</p>
<p>Again, we can run the evaluator with a simple wrapper function <code>evaluate</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">MoleculeExpr</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">MoleculeError</span> <span class="dt">MoleculeValue</span>
evaluate <span class="fu">=</span> runEval M.empty
  <span class="kw">where</span> runEval env e <span class="fu">=</span> runReader (runExceptT (eval e)) env</code></pre>
<p>…and that’s basically all there is to Molecule! The <code>mi</code> REPL is built with <a href="https://hackage.haskell.org/package/haskeline">haskeline</a> and supports type checking via <code>:t</code> (a la <code>ghci</code>) and evaluation by simply typing (no pun intended) expressions.</p>
<p>I’ve still got a long way to go in the programming languages world, but I’m proud of Molecule even if its type inference is a little flawed. My next project will either have a type system closer to <a href="http://en.wikipedia.org/wiki/Hindley–Milner_type_system">Hindley Milner</a> (so I can type infer with something closer to <a href="http://en.wikipedia.org/wiki/Hindley–Milner_type_system#Algorithm_W">Algorithm W</a>), or just make type annotations explicit (for a different set of challenges).</p>
<p>Again, Molecule’s full source code is <a href="https://github.com/5outh/Molecule">available on GitHub</a>.</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-07-21-molecule.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-04-30-hylomorphisms-and-treesort.html">Hylomorphisms and treesort</a>
	<p class="published">Published by Ben Kovach on April 30, 2014</p>
</div>
<div class="post_body">
	<p>Consider the following data structure, representing a binary search tree:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span>  <span class="dt">BST</span> a <span class="fu">=</span> 
    <span class="dt">Tree</span> (<span class="dt">BST</span> a) a (<span class="dt">BST</span> a)
  <span class="fu">|</span> <span class="dt">Empty</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre>
<p>As it turns out, this data structure provides a nice way to introduce the concepts of different types of morphisms used all over the place in Haskell - the fold, or “catamorphism”, the unfold, or “anamorphism”, and compositions of the two, the “hylomorphism” and “metamorphism.”</p>
<p>The bracket notations that I’ll use below come from Meijer, Fokkinga and Patterson’s excellent paper <a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a>. If you enjoy the article, I’d suggest giving it a look!</p>
<p>I’m writing this because I recall encountering these names when learning Haskell early on and being very confused, particularly by the latter two types. Folds (and to a lesser extent, unfolds) are commonplace in Haskell. Hylo- and metamorphisms are also pretty common, but they’re not as easy to spot. From <a href="http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)">Wikipedia</a>:</p>
<blockquote>
<p>In computer science, and in particular functional programming, a hylomorphism is a recursive function, corresponding to the composition of an anamorphism (which first builds a set of results; also known as ‘unfolding’) and a catamorphism (which then folds these results into a final return value)</p>
</blockquote>
<p>The canonical example of a hylomorphism is the factorial function, which (usually) implicitly composes functions. The goal of this post is to lay out an <strong>explicit</strong> example of a hylo- (and meta-) morphism in a natural way. We’ll start with a couple of functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a
insert x <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Empty</span> x <span class="dt">Empty</span>
insert x (<span class="dt">Tree</span> left a right)
  <span class="fu">|</span> x <span class="fu">&lt;</span> a     <span class="fu">=</span> <span class="dt">Tree</span> (treeInsert x left) a right
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Tree</span> left a (treeInsert x right)

<span class="ot">fromList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BST</span> a
fromList xs <span class="fu">=</span> foldr treeInsert <span class="dt">Empty</span> xs</code></pre>
<p>We have an insertion function and our first example of a catamorphism, <code>fromList</code>! We’re folding all values from a list into a new structure (a <code>BST</code>) and destroying the list in the process. This function can be written in so called “banana brackets,” like so: <span class="math">\(fromList = (\!\left|treeInsert\right|\!)\)</span>.</p>
<p>I<code>fromList</code> can also be considered an anamorphism. Catamorphisms destroy structures to build final values, whereas anamorphisms take an initial seed value and build a new structure from it. In <code>fromList</code>, <code>xs</code> can be considered a “seed” value to build a <code>BST a</code> from, making <code>fromList</code> a perfectly valid anamorphism as well. As such, <code>fromList</code> can also be written in “lens brackets”: <span class="math">\(fromList = [\!(treeInsert)\!]\)</span>.</p>
<p>We can also define a new pair of cata/anamorphisms by folding the tree into a list:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldTree ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> b
foldTree f b <span class="dt">Empty</span> <span class="fu">=</span> b
foldTree f b (<span class="dt">Tree</span> left a right) <span class="fu">=</span> foldTree f ( f a (foldTree f b right) ) left

<span class="ot">toList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> [a]
toList t <span class="fu">=</span> foldTree (<span class="fu">:</span>) [] t</code></pre>
<p><code>foldTree</code> is analogous to <code>foldr</code> (and would be a fine definition for <code>foldr</code> in a <code>Foldable</code> instance), and <code>toList</code> destructs (folds) a <code>BST a</code> into an <code>[a]</code>. Thinking this way, <code>toList</code> again defines a catamorphism, this time from <code>BST a -&gt; [a]</code>, denoted <span class="math">\(toList = (\!\left| : \right|\!)\)</span>. But we can also think of <code>toList</code> as unfolding a <code>BST a</code> into an <code>[a]</code>, so we can analogously define an anamorphism <span class="math">\(toList = [\!( : )\!]\)</span>.</p>
<p>There’s something interesting about <code>toList</code>: <code>foldTree</code> traverses a <code>BST</code> in order, so it actually produces a sorted list (given that elements are <code>insert</code>ed rather than randomly placed!). Now we have a way to construct a binary search tree from a list of elements, and destruct a binary search tree into a sorted list of elements. This gives rise to a simple definion of a sorting algorithm, namely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treesort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
treesort <span class="fu">=</span> toList <span class="fu">.</span> fromList</code></pre>
<p>Because <code>toList</code> and <code>fromList</code> are both cata- and anamorphims, <code>treesort</code> actually defines a hylomorphism <em>and</em> a metamorphism.</p>
<p>As we noted before, a hylomorphism is defined as the composition of an anamorphism (unfold) with a catamorphism (fold). If we think of <code>fromList</code> as an anamorphism and <code>toList</code> as a catamorphism, we have constructed a hylomorphism directly. Namely, the function <span class="math">\(treesort = [\![([], (:)),(insert, null)]\!]\)</span> (the brackets here are commonly called “envelopes”). <code>null</code> isn’t explicit in the definition of <code>treesort</code> (instead, it’s implicit in <code>foldr</code>), but it describes a terminating condition for <code>fromList</code>. Similarly, <code>[]</code> is just the container to fold values into.</p>
<p>We can once again think of this function in the opposite manner by thinking of <code>fromList</code> as a catamorphism and <code>toList</code> as an anamorphism, giving rise to a metamorphism, defined by composition in the opposite direction. Metamorphisms (as far as I know) have no bracket notation in literature, but I want to mention that we do have a name for such things. My guess is that any metamorphism can actually be thought of as a hylomorphism, since the objects being operated on must be both foldable and unfoldable, but I don’t know for sure.</p>
<p>Finally, note that we can also create another function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">what ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a
what <span class="fu">=</span> fromList <span class="fu">.</span> toList</code></pre>
<p>which is also a hylo- and metamorphism. However, this isn’t very useful (in fact, one might consider it counterproductive), but I’ll leave it as an exercise to the reader to figure out why.</p>
<p>Thanks for reading!</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-04-30-hylomorphisms-and-treesort.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-04-19-What-the-Haskell-Code.html">What the Haskell!? Code</a>
	<p class="published">Published by Ben Kovach on April 19, 2014</p>
</div>
<div class="post_body">
	<p>I recently presented a talk for the UGA ACM, so I’ve posted the slides <a href="https://5outh.github.io/What-the-Haskell.pdf">here</a>. A completed copy of the code involved can also be found <a href="https://github.com/5outh/HaskellTalk">in a github repository here</a>.</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-04-19-What-the-Haskell-Code.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2013-12-19-bots4-clone.html">Making a Bots2 clone using Lenses and Pipes</a>
	<p class="published">Published by Ben Kovach on December 19, 2013</p>
</div>
<div class="post_body">
	<h4 id="about-bots2">About bots2</h4>
<p>When I was in high school, I came across an internet game called bots2. Bots2 was a multiplayer game where people can log in, customize a robot, and autonomously fight against pre-built AI and other human players. The game would progress in rounds, wherein each robot would attempt to destroy its adversary. The game would continue until one robot dropped below 0 health, at which point the other robot would emerge victorious.</p>
<p>Bots2 was purportedly <a href="http://bots4.net/documentation">attacked by hackers</a> and never brought back up. However, <a href="http://edmazur.com/">someone</a> has taken the liberty of creating a clone of the old game, named bots4. If you’re interested, <a href="http://bots4.net/">you can play bots4 here</a>. In fact, I might recommend playing around with it for a minute or two, because we’ll be building a (very) simple version of bots2 in this post!</p>
<h4 id="preliminaries">Preliminaries</h4>
<p>I only assume a basic familiarity with monad transformers in this post. If you need an introduction, <a href="http://blog.sigfpe.com">sigfpe</a> has a <a href="http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html">great introduction to them on his blog</a>. We’ll be using Russell O’Connor’s <a href="http://hackage.haskell.org/package/lens-family">Lens-Family</a> and Gabriel Gonzalez’ <a href="http://hackage.haskell.org/package/pipes">Pipes</a> libraries to make the implementation easy (and educational!).</p>
<p>I also want to give a shout out to Gabriel, who was generous enough to personally review and edit my initial draft of the code in this post – it looks much better than it did before, thanks to him.</p>
<p>Without further ado, let’s get started!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Pipes</span>
<span class="kw">import qualified</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span>
<span class="kw">import qualified</span> <span class="dt">System.Random</span> <span class="kw">as</span> <span class="dt">R</span>
<span class="kw">import           </span><span class="dt">Lens.Family2</span>             
<span class="kw">import           </span><span class="dt">Lens.Family2.Stock</span>       
<span class="kw">import           </span><span class="dt">Lens.Family2.State.Lazy</span> 
<span class="kw">import           </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import           </span><span class="dt">Control.Monad</span>
<span class="kw">import           </span><span class="dt">Control.Concurrent</span>(threadDelay)</code></pre>
<h4 id="modeling-bots">Modeling Bots</h4>
<p>The game we wish to build pits two bots against each other, who will fight to the death based on who has the better stats (and a bit of randomness). We’ll need to be able to model each bot as an entity along with its specific stats.</p>
<p>During each round, each bot:</p>
<ol style="list-style-type: decimal">
<li>Deals damage to its opponent</li>
<li>Has a chance to block (and take half damage)</li>
<li>Has a chance to dodge (and take no damage)</li>
</ol>
<p>We’ll model a <code>Bot</code> like so:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bot</span> <span class="fu">=</span> <span class="dt">Bot</span>
    { _<span class="ot">name ::</span> <span class="dt">String</span>
    , _<span class="ot">str  ::</span> <span class="dt">Int</span>
    , _<span class="ot">dex  ::</span> <span class="dt">Int</span>
    , _<span class="ot">con  ::</span> <span class="dt">Int</span>
    , _<span class="ot">hp   ::</span> <span class="dt">Int</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<p>We’ll use <code>str</code> to modify damage output, <code>dex</code> to modify dodge chance, <code>con</code> to modify block chance, and <code>hp</code> to denote the amount of health the bot has remaining. We’ll also tack on a <code>name</code> so we can print out more informative messages during the game. Note the prefix <code>_</code> on each field; these are here so we can give our <code>Lens</code>es nicer names.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">name ::</span> <span class="dt">Lens'</span> <span class="dt">Bot</span> <span class="dt">String</span>
str, dex, con,<span class="ot"> hp ::</span> <span class="dt">Lens'</span> <span class="dt">Bot</span> <span class="dt">Int</span>
name k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\nm' <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm' s d c h) (k nm)
str  k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\s'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s' d c h) (k s )
dex  k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\d'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s d' c h) (k d )
con  k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\c'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s d c' h) (k c )
hp   k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\h'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s d c h') (k h )</code></pre>
<p>We can now define some <code>Lens</code>es for our <code>Bot</code> fields. We do this manually because it’s relatively simple and to avoid the <code>TemplateHaskell</code> requirement that comes along with Edward Kmett’s larger <a href="http://hackage.haskell.org/package/lens-3.10.0.1">Lens</a> library. Given a more complicated system, we might choose to use <a href="http://hackage.haskell.org/package/lens-3.10.0.1">Lens</a> to automatically generate these. However, this is a small program so the overhead isn’t necessary. Also, don’t worry too much about the declarations of the <code>Lens</code>es above: Just know that they allow us to do some cool stuff later on.</p>
<p>With these <code>Lens</code>es defined and our <code>Bot</code> data type in place, we can move on to defining more of the game’s semantics.</p>
<h4 id="more-types">More Types</h4>
<p>We’ll need a data type to represent a bot’s actions during a single round, and a game state representing the global state of the game:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Event</span>    <span class="fu">=</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Bool</span>)
<span class="kw">type</span> <span class="dt">BotState</span> <span class="fu">=</span> (<span class="dt">R.StdGen</span>, (<span class="dt">Bot</span>, <span class="dt">Bot</span>))</code></pre>
<p>The <code>Event</code> type defines a round of a single Bot’s behavior in a 3-tuple – the first parameter corresponds to damage dealt, the second to whether or not the bot dodged, and the third to whether or not the bot blocked. We will process these events later.</p>
<p>The <code>BotState</code> type boxes up a <code>StdGen</code> for us to use when generating random events, and a 2-tuple of <code>Bot</code>s – the player character’s bot and the enemy AI. This is all the global state we need in our game.</p>
<p>We can make some new <code>Lens</code>es for these types, given that 2-tuples are easily indexed using <code>Lens</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generator ::</span> <span class="dt">Lens'</span> <span class="dt">BotState</span> <span class="dt">R.StdGen</span>
generator <span class="fu">=</span> _1

<span class="ot">player ::</span> <span class="dt">Lens'</span> <span class="dt">BotState</span> <span class="dt">Bot</span>
player <span class="fu">=</span> _2<span class="fu">.</span>_1

<span class="ot">enemy ::</span> <span class="dt">Lens'</span> <span class="dt">BotState</span> <span class="dt">Bot</span>
enemy <span class="fu">=</span> _2<span class="fu">.</span>_2</code></pre>
<p>Here we create a <code>Lens</code> that references the <code>StdGen</code> of the <code>BotState</code>, using <code>_1</code>. We can also compose <code>Lens</code>es using <code>.</code> (from the <code>Prelude</code>!) and we use this functionality with the simple <code>Lens</code>es <code>_1</code> and <code>_2</code> to make <code>Lens</code>es referencing the player and enemy AI in a <code>BotState</code>.</p>
<p>Well, that’s about all the type declaring we need to do. Now we can get on with piecing together the actual gameplay.</p>
<h4 id="generating-events">Generating Events</h4>
<p>Now comes the fun part: actually programming the game mechanics. Essentially what we’d like to do is the following:</p>
<ol style="list-style-type: decimal">
<li>Generate an event for the player and enemy at the same time.</li>
<li>Process each event.</li>
<li>If either bot is dead, end the game and print an ending message.</li>
</ol>
<p>Here we’ll focus on (1), generating events. Let’s take a look at some code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genEvent ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">R.StdGen</span> <span class="dt">IO</span> <span class="dt">Event</span>
genEvent bot <span class="fu">=</span> <span class="kw">do</span>
    [n, m, r] <span class="ot">&lt;-</span> replicateM <span class="dv">3</span> <span class="fu">$</span> state (R.randomR (<span class="dv">0</span>, <span class="dv">100</span>))
    <span class="kw">let</span> dodge <span class="fu">=</span> n <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">*</span> bot<span class="fu">^.</span>dex <span class="ot">`div`</span> (bot<span class="fu">^.</span>dex <span class="fu">+</span> <span class="dv">50</span>)
        block <span class="fu">=</span> m <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">*</span> bot<span class="fu">^.</span>con <span class="ot">`div`</span> (bot<span class="fu">^.</span>con <span class="fu">+</span> <span class="dv">30</span>)
        dmg   <span class="fu">=</span> bot<span class="fu">^.</span>str <span class="fu">+</span> (bot<span class="fu">^.</span>str <span class="fu">*</span> r) <span class="ot">`div`</span> <span class="dv">30</span>
    return (dmg, dodge, block)</code></pre>
<p>In order to generate an event for a bot, we grab three numbers between 0 and 100:</p>
<ul>
<li>n, which helps determine if the bot dodges,</li>
<li>m, which helps determine if the bot blocks,</li>
<li>and r, which helps determine how much damage the bot does.</li>
</ul>
<p>We can use the <code>state</code> combinator here to lift the computation <code>(R.randomR (0, 100))</code> to a computation in the <code>StateT</code> monad. We then perform some arithmetic using the random numbers we grabbed along with the <code>dex</code>, <code>con</code>, and <code>str</code> stats from our <code>Bot</code>. We access these using the <code>^.</code> combinator from the <code>lens-family</code>, using the <code>Lens</code>es we defined above.</p>
<p>Important note: We are producing the amount of damage a bot <em>deals</em> here. We will want to process events according to how much damage each bot <em>receives</em>, which we’ll handle in a minute.</p>
<p>Now that we can generate single events, we need a way of mapping them to specific bots. We’ll define a new function, <code>genEventPair</code>, to generate <em>two</em> events at once, corresponding to the player and the enemy in the game.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genEventPair ::</span> <span class="dt">StateT</span> <span class="dt">BotState</span> <span class="dt">IO</span> (<span class="dt">Event</span>, <span class="dt">Event</span>)
genEventPair <span class="fu">=</span> <span class="kw">do</span>
    p <span class="ot">&lt;-</span> use player
    e <span class="ot">&lt;-</span> use enemy
    zoom generator <span class="fu">$</span> liftM2 switchDmgs (genEvent p) (genEvent e)
  <span class="kw">where</span>
    switchDmgs (a, b, c) (d, e, f) <span class="fu">=</span> ( (d, b, c), (a, e, f) )</code></pre>
<p>There are a couple of new things at play here. First, on <code>use</code>:</p>
<p>Note the use of our <code>Lens</code>es <code>player</code> and <code>enemy</code>. To access the underlying state in a <code>StateT</code>, we typically call the function <code>lift</code>. Here instead we call the function <code>use</code> from <code>Lens.Family2.State</code>, which allows us to specify which <em>piece</em> of our <code>BotState</code> we want to get. We do just this in order to generate events for both the <code>player</code> and <code>enemy</code>, using the aforementioned <code>Lens</code>es.</p>
<p>Next, if you were looking closely you might have noticed that <code>genEvent</code> isn’t operating in the same monad as <code>genEventPair</code>, yet we use <code>genEvent</code> inside of <code>genEventPair</code>! We are able do do this using the <code>zoom</code> combinator.</p>
<p><code>zoom</code> lifts a stateful operation on one field to a stateful operation on the entire state. Here, we’re zooming into <code>generator</code> (a <code>Lens</code> on our <code>StdGen</code>) and lifting the (stateful) generation of events for both the player and enemy into a (stateful) generation of <em>two</em> events while preserving player and enemy states. The fact that we can <code>zoom</code> into <code>genEvent</code> helps out the declaration immensely. It removes a lot of plumbing that we would have had to deal with in order to have <code>genEvent</code> operate on an underlying state of type <code>BotState</code> and allows the type of the computation to be more explicit.</p>
<p>Finally, Note the use of <code>switchDmgs</code> here: This was an ad hoc way to switch around damage dealt and damage sustained. <code>genEventPair</code> produces events harboring damage <em>taken</em>, which is what we need in order to process them in a nice way.</p>
<h4 id="processing-events">Processing Events</h4>
<p>Now that we’re able to generate events and keep track of our game state, the next thing we need to do is actually process these events and update game state. We introduce <code>resolveEvent</code> to take care of this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">resolveEvent ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (<span class="dt">Event</span>, <span class="dt">Event</span>) <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">BotState</span> m [(<span class="dt">Bot</span>, <span class="dt">Event</span>)]
resolveEvent (p_evt, e_evt) <span class="fu">=</span> <span class="kw">do</span>
    zoom player (resolve p_evt)
    zoom enemy  (resolve e_evt)
    p <span class="ot">&lt;-</span> use player
    e <span class="ot">&lt;-</span> use enemy
    return [(p, p_evt), (e, e_evt)]

<span class="ot">resolve ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">Bot</span> m ()
resolve (dmg, ddg, blk)
    <span class="fu">|</span> ddg       <span class="fu">=</span> return ()
    <span class="fu">|</span> blk       <span class="fu">=</span> hp <span class="fu">-=</span> dmg <span class="ot">`div`</span> <span class="dv">2</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> hp <span class="fu">-=</span> dmg</code></pre>
<p>First let’s look at the <code>resolve</code> function. Here we are taking an event and updating a <code>Bot</code>’s state based on that event. The implementation is straightforward, especially given that we have the <code>-=</code> <code>Lens</code> combinator at our disposal – this allows us to write imperative-looking code that does exactly what you would expect it to.</p>
<p>In the <code>resolveEvent</code> function, you should see some similarities to the above section. We can again use <code>zoom</code> and <code>use</code> in order to lift computations and retrieve state just as before, but we’re updating the main game state now. We produce two 2-tuples containing modified bots and their attached event that was processed during each turn.</p>
<p>At this point, the game logic is actually finished. We have ways to produce and deal with game events that modify game state, and provided that we can actually link these functions together (which we can, as we’ll see later), the game will actually run. All that we need to do now is handle IO and bot death. This is where <code>Pipes</code> comes in.</p>
<h4 id="pipes-and-io">Pipes and IO</h4>
<p>Let’s get the boring stuff out of the way first. I mentioned above that we have yet to deal with two major components of our game: IO and bot death. Let’s first define some simple functions to deal with these:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dead ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
dead <span class="fu">=</span> (<span class="fu">&lt;=</span> <span class="dv">0</span>) <span class="fu">.</span> view hp

<span class="ot">printBot ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printBot bot <span class="fu">=</span> putStrLn <span class="fu">$</span> bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; has &quot;</span> <span class="fu">++</span> show (bot<span class="fu">^.</span>hp) <span class="fu">++</span> <span class="st">&quot; hp remaining.&quot;</span>

<span class="ot">printEvent ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printEvent bot (_, <span class="dt">True</span>, _) <span class="fu">=</span> putStrLn <span class="fu">$</span>
  bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; dodges the attack and takes no damage!&quot;</span>
printEvent bot (d, _, <span class="dt">True</span>) <span class="fu">=</span> putStrLn <span class="fu">$</span> 
  bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; blocks and takes half (&quot;</span> <span class="fu">++</span> show (d <span class="ot">`div`</span> <span class="dv">2</span>) <span class="fu">++</span> <span class="st">&quot;) damage!&quot;</span>
printEvent bot (d, _,    _) <span class="fu">=</span> putStrLn <span class="fu">$</span> 
  bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; takes &quot;</span> <span class="fu">++</span> show d <span class="fu">++</span> <span class="st">&quot; damage.&quot;</span></code></pre>
<p>Here we again make use of our <code>Lens</code>es (these are handy, huh?). We use the <code>view</code> function in order to get the health of our bot in <code>dead</code>, and check whether its hp is less than 0 in the usual fashion. <code>view</code> is just a prefix synonym for the infix <code>^.</code> that we’ve been using all this time. Speaking of which, we use the <code>^.</code> combinator heavily in both <code>printEvent</code> and <code>printBot</code> to handle the string-handling plumbing. Since these functions essentially tell you what they’re doing implicitly, I’ll omit an extensive explanation.</p>
<p>Now that we have ways to print <code>Bot</code>s and <code>Event</code>s and check for bot death, the last thing we need to do is actually perform these things the context of our game. A <code>Consumer</code> from the <code>Pipes</code> library will handle this nicely for us:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printGame ::</span> <span class="dt">Consumer</span> [(<span class="dt">Bot</span>, <span class="dt">Event</span>)] (<span class="dt">StateT</span> <span class="dt">BotState</span> <span class="dt">IO</span>) ()
printGame <span class="fu">=</span> <span class="kw">do</span>
    botEvents<span class="fu">@</span>[(b1, e1), (b2, e2)] <span class="ot">&lt;-</span> await
    (lift <span class="fu">.</span> lift) <span class="fu">$</span> <span class="kw">do</span>
        forM_ botEvents <span class="fu">$</span> \be<span class="fu">@</span>(bot, event) <span class="ot">-&gt;</span> <span class="kw">do</span>
            uncurry printEvent be
            printBot bot
            threadDelay <span class="dv">500000</span>
            when (dead bot) <span class="fu">$</span> putStrLn <span class="fu">$</span> bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; died!&quot;</span>
        putStrLn <span class="fu">$</span> <span class="kw">case</span> (dead b1, dead b2) <span class="kw">of</span>
            (<span class="dt">True</span> , <span class="dt">True</span> ) <span class="ot">-&gt;</span> <span class="st">&quot;It was a tie!&quot;</span>
            (<span class="dt">True</span> , <span class="dt">False</span>) <span class="ot">-&gt;</span> b2<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; wins!&quot;</span>
            (<span class="dt">False</span>, <span class="dt">True</span> ) <span class="ot">-&gt;</span> b1<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; wins!&quot;</span>
            _              <span class="ot">-&gt;</span> <span class="st">&quot;-----------------&quot;</span>
    unless (any (dead <span class="fu">.</span> fst) botEvents) printGame</code></pre>
<p>We <code>await</code> two <code>(Bot, Event)</code>s (from where, you might ask? We’ll see in a moment.) and essentially handle all of the plumbing here. For each pair of bots and events, we print the event, print the bot, then wait half a second with <code>threadDelay</code> (otherwise the game would run too quickly and we wouldn’t see it play out). With a <code>Consumer</code> like this, we need to loop until we’ve consumed all of the input we want, so we use the <code>when</code> and <code>unless</code> functions from <code>Control.Monad</code> as indicators of when to do so. If a bot dies, we stop – we also print out some information about who died and who won the game.</p>
<h4 id="running-the-game">Running the Game</h4>
<p>Okay, so I say that we have everything we need now, but you might ask…how do I run this? Let’s take a look at a program that pits two bots – a good guy and a bad guy – against one another, and we’ll dissect it.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runGame ::</span> <span class="dt">IO</span> ()
runGame <span class="fu">=</span> <span class="kw">do</span>
    gen <span class="ot">&lt;-</span> R.getStdGen
    <span class="kw">let</span> player <span class="fu">=</span> <span class="dt">Bot</span> <span class="st">&quot;The Good Guy&quot;</span> <span class="dv">19</span> <span class="dv">13</span> <span class="dv">12</span> <span class="dv">200</span>
        enemy  <span class="fu">=</span> <span class="dt">Bot</span> <span class="st">&quot;The Bad Guy&quot;</span>  <span class="dv">14</span> <span class="dv">6</span>  <span class="dv">10</span> <span class="dv">200</span>
        startState <span class="fu">=</span> (gen, (player, enemy))
    flip evalStateT startState 
      <span class="fu">$</span> runEffect 
      <span class="fu">$</span> lift (genEventPair <span class="fu">&gt;&gt;=</span> resolveEvent) <span class="fu">&gt;~</span> printGame</code></pre>
<p>In the first few lines, we simply set up an initial state for the game. The real “stuff” happens in the line starting with <code>flip evalStateT</code>. We’ll work through this at a type level from the inside-out. First, we perform <code>genEventPair &gt;&gt;= resolveEvent</code>, which effectively handles the logic we talked about earlier and produces a <code>StateT BotState IO [(Bot, Event)]</code>. From here, we <code>lift</code> the computation into an <code>Effect (StateT BotState IO) [(Bot, Event)]</code>, which we then repeatedly pipe into <code>printGame</code> with <code>&gt;~</code>. After all of this, we <code>runEffect</code> to extract the <code>StateT BotState IO [(Bot, Event)]</code> from the computation, and finally evaluate the function using <code>evalStateT</code>. Phew!</p>
<p>In any case, we can now run our program and execute the game…</p>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; runGame
The Good Guy takes <span class="dv">15</span> damage.
The Good Guy has <span class="dv">285</span> hp remaining.
The Bad Guy takes <span class="dv">29</span> damage.
The Bad Guy has <span class="dv">171</span> hp remaining.
-----------------
The Good Guy dodges the attack and takes no damage!
The Good Guy has <span class="dv">285</span> hp remaining.
The Bad Guy takes <span class="dv">20</span> damage.
The Bad Guy has <span class="dv">151</span> hp remaining.
-----------------
The Good Guy blocks and takes half (<span class="dv">24</span>) damage!
The Good Guy has <span class="dv">261</span> hp remaining.
The Bad Guy takes <span class="dv">34</span> damage.
The Bad Guy has <span class="dv">117</span> hp remaining.
-----------------
The Good Guy takes <span class="dv">46</span> damage.
The Good Guy has <span class="dv">215</span> hp remaining.
The Bad Guy takes <span class="dv">19</span> damage.
The Bad Guy has <span class="dv">98</span> hp remaining.
-----------------
The Good Guy takes <span class="dv">32</span> damage.
The Good Guy has <span class="dv">183</span> hp remaining.
The Bad Guy takes <span class="dv">37</span> damage.
The Bad Guy has <span class="dv">61</span> hp remaining.
-----------------
The Good Guy dodges the attack and takes no damage!
The Good Guy has <span class="dv">183</span> hp remaining.
The Bad Guy takes <span class="dv">12</span> damage.
The Bad Guy has <span class="dv">49</span> hp remaining.
-----------------
The Good Guy takes <span class="dv">24</span> damage.
The Good Guy has <span class="dv">159</span> hp remaining.
The Bad Guy takes <span class="dv">23</span> damage.
The Bad Guy has <span class="dv">26</span> hp remaining.
-----------------
The Good Guy dodges the attack and takes no damage!
The Good Guy has <span class="dv">159</span> hp remaining.
The Bad Guy takes <span class="dv">36</span> damage.
The Bad Guy has -<span class="dv">10</span> hp remaining.
The Bad Guy died!
The Good Guy wins!</code></pre>
<p>…and behold, the good guy wins (this time)!</p>
<p><a href="https://gist.github.com/5outh/8049361">View full source on GitHub</a>.</p>
<p>- Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2013-12-19-bots4-clone.html#disqus_thread"></a>
    	</li>
    
</ul>
            </div>
        </div>
      </div>
        <footer>
            <p id="copyright">© Benjamin Kovach, 2013 <br />
                              Follow me on <a href="http://github.com/5outh">GitHub</a> and <a href="http://twitter.com/bendotk">Twitter</a>!<br />
                              Looking for an older post? <a href="archive.html">Check out the archive</a>.
                </div>
                </p>
        </footer>
        <script type="text/javascript">
        var disqus_shortname = 'abstract-nonsense';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());

        </script>
    </body>
</html>
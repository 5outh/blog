<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" style="position:relative;">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Abstract Nonsense - Ramblings</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/syntax.css" />
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
        <script src="./js/Utils.js"></script>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <link href="http://fonts.googleapis.com/css?family=Alegreya+Sans+SC|Della+Respira|Montaga" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Roboto:400,100" rel="stylesheet" type="text/css">
    </head>
    <body id="main">
        <div id="header">
            <div id="logo">
                <a href="./" id="main_title">Abstract Nonsense</a>
                <p id="main_subtitle"><br /><a href="./">By Benjamin Kovach</a></p>
            </div>
            <div id="navigation">
                <table>
                <td>
                    <tr><a href="./">Home</a></tr>
                    <tr><a href="./contact.html">A</tr>bout</a></tr>
                    <tr><a href="./cv.html">CV</a></tr>
                    <tr><a href="./archive.html">Archive</a></tr>
                    <tr><a href="./atom.xml">Atom</a></tr>
                </td>
                </table>
            </div>
        </div>
        <div id="content">
            <center><!-- <h1 class="title"><a href="#">Ramblings</a></h1> -->
                
                
                    </center>
            <div id="main_body">
                <ul class="blog_list">
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-04-30-hylomorphisms-and-treesort.html">Hylomorphisms and treesort</a>
	<p class="published">Published by Ben Kovach on April 30, 2014</p>
</div>
<div class="post_body">
	<p>Consider the following data structure, representing a binary search tree:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span>  <span class="dt">BST</span> a <span class="fu">=</span> 
    <span class="dt">Tree</span> (<span class="dt">BST</span> a) a (<span class="dt">BST</span> a)
  <span class="fu">|</span> <span class="dt">Empty</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre>
<p>As it turns out, this data structure provides a nice way to introduce the concepts of different types of morphisms used all over the place in Haskell - the fold, or “catamorphism”, the unfold, or “anamorphism”, and compositions of the two, the “hylomorphism” and “metamorphism.”</p>
<p>The bracket notations that I’ll use below come from Meijer, Fokkinga and Patterson’s excellent paper <a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a>. If you enjoy the article, I’d suggest giving it a look!</p>
<p>I’m writing this because I recall encountering these names when learning Haskell early on and being very confused, particularly by the latter two types. Folds (and to a lesser extent, unfolds) are commonplace in Haskell. Hylo- and metamorphisms are also pretty common, but they’re not as easy to spot. From <a href="http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)">Wikipedia</a>:</p>
<blockquote>
<p>In computer science, and in particular functional programming, a hylomorphism is a recursive function, corresponding to the composition of an anamorphism (which first builds a set of results; also known as ‘unfolding’) and a catamorphism (which then folds these results into a final return value)</p>
</blockquote>
<p>The canonical example of a hylomorphism is the factorial function, which (usually) implicitly composes functions. The goal of this post is to lay out an <strong>explicit</strong> example of a hylo- (and meta-) morphism in a natural way. We’ll start with a couple of functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a
insert x <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Empty</span> x <span class="dt">Empty</span>
insert x (<span class="dt">Tree</span> left a right)
  <span class="fu">|</span> x <span class="fu">&lt;</span> a     <span class="fu">=</span> <span class="dt">Tree</span> (treeInsert x left) a right
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Tree</span> left a (treeInsert x right)

<span class="ot">fromList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BST</span> a
fromList xs <span class="fu">=</span> foldr treeInsert <span class="dt">Empty</span> xs</code></pre>
<p>We have an insertion function and our first example of a catamorphism, <code>fromList</code>! We’re folding all values from a list into a new structure (a <code>BST</code>) and destroying the list in the process. This function can be written in so called “banana brackets,” like so: <span class="math">\(fromList = (\!\left|treeInsert\right|\!)\)</span>.</p>
<p>I<code>fromList</code> can also be considered an anamorphism. Catamorphisms destroy structures to build final values, whereas anamorphisms take an initial seed value and build a new structure from it. In <code>fromList</code>, <code>xs</code> can be considered a “seed” value to build a <code>BST a</code> from, making <code>fromList</code> a perfectly valid anamorphism as well. As such, <code>fromList</code> can also be written in “lens brackets”: <span class="math">\(fromList = [\!(treeInsert)\!]\)</span>.</p>
<p>We can also define a new pair of cata/anamorphisms by folding the tree into a list:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldTree ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> b
foldTree f b <span class="dt">Empty</span> <span class="fu">=</span> b
foldTree f b (<span class="dt">Tree</span> left a right) <span class="fu">=</span> foldTree f ( f a (foldTree f b right) ) left

<span class="ot">toList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> [a]
toList t <span class="fu">=</span> foldTree (<span class="fu">:</span>) [] t</code></pre>
<p><code>foldTree</code> is analogous to <code>foldr</code> (and would be a fine definition for <code>foldr</code> in a <code>Foldable</code> instance), and <code>toList</code> destructs (folds) a <code>BST a</code> into an <code>[a]</code>. Thinking this way, <code>toList</code> again defines a catamorphism, this time from <code>BST a -&gt; [a]</code>, denoted <span class="math">\(toList = (\!\left| : \right|\!)\)</span>. But we can also think of <code>toList</code> as unfolding a <code>BST a</code> into an <code>[a]</code>, so we can analogously define an anamorphism <span class="math">\(toList = [\!( : )\!]\)</span>.</p>
<p>There’s something interesting about <code>toList</code>: <code>foldTree</code> traverses a <code>BST</code> in order, so it actually produces a sorted list (given that elements are <code>insert</code>ed rather than randomly placed!). Now we have a way to construct a binary search tree from a list of elements, and destruct a binary search tree into a sorted list of elements. This gives rise to a simple definion of a sorting algorithm, namely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treesort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
treesort <span class="fu">=</span> toList <span class="fu">.</span> fromList</code></pre>
<p>Because <code>toList</code> and <code>fromList</code> are both cata- and anamorphims, <code>treesort</code> actually defines a hylomorphism <em>and</em> a metamorphism.</p>
<p>As we noted before, a hylomorphism is defined as the composition of an anamorphism (unfold) with a catamorphism (fold). If we think of <code>fromList</code> as an anamorphism and <code>toList</code> as a catamorphism, we have constructed a hylomorphism directly. Namely, the function <span class="math">\(treesort = [\![([], (:)),(insert, null)]\!]\)</span> (the brackets here are commonly called “envelopes”). <code>null</code> isn’t explicit in the definition of <code>treesort</code> (instead, it’s implicit in <code>foldr</code>), but it describes a terminating condition for <code>fromList</code>. Similarly, <code>[]</code> is just the container to fold values into.</p>
<p>We can once again think of this function in the opposite manner by thinking of <code>fromList</code> as a catamorphism and <code>toList</code> as an anamorphism, giving rise to a metamorphism, defined by composition in the opposite direction. Metamorphisms (as far as I know) have no bracket notation in literature, but I want to mention that we do have a name for such things. My guess is that any metamorphism can actually be thought of as a hylomorphism, since the objects being operated on must be both foldable and unfoldable, but I don’t know for sure.</p>
<p>Finally, note that we can also create another function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">what ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">BST</span> a <span class="ot">-&gt;</span> <span class="dt">BST</span> a
what <span class="fu">=</span> fromList <span class="fu">.</span> toList</code></pre>
<p>which is also a hylo- and metamorphism. However, this isn’t very useful (in fact, one might consider it counterproductive), but I’ll leave it as an exercise to the reader to figure out why.</p>
<p>Thanks for reading!</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-04-30-hylomorphisms-and-treesort.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2014-04-19-What-the-Haskell-Code.html">What the Haskell!? Code</a>
	<p class="published">Published by Ben Kovach on April 19, 2014</p>
</div>
<div class="post_body">
	<p>I recently presented a talk for the UGA ACM, so I’ve posted the slides <a href="https://5outh.github.io/What-the-Haskell.pdf">here</a>. A completed copy of the code involved can also be found <a href="https://github.com/5outh/HaskellTalk">in a github repository here</a>.</p>
<p>Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2014-04-19-What-the-Haskell-Code.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2013-12-19-bots4-clone.html">Making a Bots2 clone using Lenses and Pipes</a>
	<p class="published">Published by Ben Kovach on December 19, 2013</p>
</div>
<div class="post_body">
	<h4 id="about-bots2">About bots2</h4>
<p>When I was in high school, I came across an internet game called bots2. Bots2 was a multiplayer game where people can log in, customize a robot, and autonomously fight against pre-built AI and other human players. The game would progress in rounds, wherein each robot would attempt to destroy its adversary. The game would continue until one robot dropped below 0 health, at which point the other robot would emerge victorious.</p>
<p>Bots2 was purportedly <a href="http://bots4.net/documentation">attacked by hackers</a> and never brought back up. However, <a href="http://edmazur.com/">someone</a> has taken the liberty of creating a clone of the old game, named bots4. If you’re interested, <a href="http://bots4.net/">you can play bots4 here</a>. In fact, I might recommend playing around with it for a minute or two, because we’ll be building a (very) simple version of bots2 in this post!</p>
<h4 id="preliminaries">Preliminaries</h4>
<p>I only assume a basic familiarity with monad transformers in this post. If you need an introduction, <a href="http://blog.sigfpe.com">sigfpe</a> has a <a href="http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html">great introduction to them on his blog</a>. We’ll be using Russell O’Connor’s <a href="http://hackage.haskell.org/package/lens-family">Lens-Family</a> and Gabriel Gonzalez’ <a href="http://hackage.haskell.org/package/pipes">Pipes</a> libraries to make the implementation easy (and educational!).</p>
<p>I also want to give a shout out to Gabriel, who was generous enough to personally review and edit my initial draft of the code in this post – it looks much better than it did before, thanks to him.</p>
<p>Without further ado, let’s get started!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Pipes</span>
<span class="kw">import qualified</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span>
<span class="kw">import qualified</span> <span class="dt">System.Random</span> <span class="kw">as</span> <span class="dt">R</span>
<span class="kw">import           </span><span class="dt">Lens.Family2</span>             
<span class="kw">import           </span><span class="dt">Lens.Family2.Stock</span>       
<span class="kw">import           </span><span class="dt">Lens.Family2.State.Lazy</span> 
<span class="kw">import           </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import           </span><span class="dt">Control.Monad</span>
<span class="kw">import           </span><span class="dt">Control.Concurrent</span>(threadDelay)</code></pre>
<h4 id="modeling-bots">Modeling Bots</h4>
<p>The game we wish to build pits two bots against each other, who will fight to the death based on who has the better stats (and a bit of randomness). We’ll need to be able to model each bot as an entity along with its specific stats.</p>
<p>During each round, each bot:</p>
<ol style="list-style-type: decimal">
<li>Deals damage to its opponent</li>
<li>Has a chance to block (and take half damage)</li>
<li>Has a chance to dodge (and take no damage)</li>
</ol>
<p>We’ll model a <code>Bot</code> like so:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bot</span> <span class="fu">=</span> <span class="dt">Bot</span>
    { _<span class="ot">name ::</span> <span class="dt">String</span>
    , _<span class="ot">str  ::</span> <span class="dt">Int</span>
    , _<span class="ot">dex  ::</span> <span class="dt">Int</span>
    , _<span class="ot">con  ::</span> <span class="dt">Int</span>
    , _<span class="ot">hp   ::</span> <span class="dt">Int</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<p>We’ll use <code>str</code> to modify damage output, <code>dex</code> to modify dodge chance, <code>con</code> to modify block chance, and <code>hp</code> to denote the amount of health the bot has remaining. We’ll also tack on a <code>name</code> so we can print out more informative messages during the game. Note the prefix <code>_</code> on each field; these are here so we can give our <code>Lens</code>es nicer names.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">name ::</span> <span class="dt">Lens'</span> <span class="dt">Bot</span> <span class="dt">String</span>
str, dex, con,<span class="ot"> hp ::</span> <span class="dt">Lens'</span> <span class="dt">Bot</span> <span class="dt">Int</span>
name k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\nm' <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm' s d c h) (k nm)
str  k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\s'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s' d c h) (k s )
dex  k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\d'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s d' c h) (k d )
con  k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\c'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s d c' h) (k c )
hp   k (<span class="dt">Bot</span> nm s d c h)  <span class="fu">=</span> fmap (\h'  <span class="ot">-&gt;</span> <span class="dt">Bot</span> nm s d c h') (k h )</code></pre>
<p>We can now define some <code>Lens</code>es for our <code>Bot</code> fields. We do this manually because it’s relatively simple and to avoid the <code>TemplateHaskell</code> requirement that comes along with Edward Kmett’s larger <a href="http://hackage.haskell.org/package/lens-3.10.0.1">Lens</a> library. Given a more complicated system, we might choose to use <a href="http://hackage.haskell.org/package/lens-3.10.0.1">Lens</a> to automatically generate these. However, this is a small program so the overhead isn’t necessary. Also, don’t worry too much about the declarations of the <code>Lens</code>es above: Just know that they allow us to do some cool stuff later on.</p>
<p>With these <code>Lens</code>es defined and our <code>Bot</code> data type in place, we can move on to defining more of the game’s semantics.</p>
<h4 id="more-types">More Types</h4>
<p>We’ll need a data type to represent a bot’s actions during a single round, and a game state representing the global state of the game:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Event</span>    <span class="fu">=</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Bool</span>)
<span class="kw">type</span> <span class="dt">BotState</span> <span class="fu">=</span> (<span class="dt">R.StdGen</span>, (<span class="dt">Bot</span>, <span class="dt">Bot</span>))</code></pre>
<p>The <code>Event</code> type defines a round of a single Bot’s behavior in a 3-tuple – the first parameter corresponds to damage dealt, the second to whether or not the bot dodged, and the third to whether or not the bot blocked. We will process these events later.</p>
<p>The <code>BotState</code> type boxes up a <code>StdGen</code> for us to use when generating random events, and a 2-tuple of <code>Bot</code>s – the player character’s bot and the enemy AI. This is all the global state we need in our game.</p>
<p>We can make some new <code>Lens</code>es for these types, given that 2-tuples are easily indexed using <code>Lens</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generator ::</span> <span class="dt">Lens'</span> <span class="dt">BotState</span> <span class="dt">R.StdGen</span>
generator <span class="fu">=</span> _1

<span class="ot">player ::</span> <span class="dt">Lens'</span> <span class="dt">BotState</span> <span class="dt">Bot</span>
player <span class="fu">=</span> _2<span class="fu">.</span>_1

<span class="ot">enemy ::</span> <span class="dt">Lens'</span> <span class="dt">BotState</span> <span class="dt">Bot</span>
enemy <span class="fu">=</span> _2<span class="fu">.</span>_2</code></pre>
<p>Here we create a <code>Lens</code> that references the <code>StdGen</code> of the <code>BotState</code>, using <code>_1</code>. We can also compose <code>Lens</code>es using <code>.</code> (from the <code>Prelude</code>!) and we use this functionality with the simple <code>Lens</code>es <code>_1</code> and <code>_2</code> to make <code>Lens</code>es referencing the player and enemy AI in a <code>BotState</code>.</p>
<p>Well, that’s about all the type declaring we need to do. Now we can get on with piecing together the actual gameplay.</p>
<h4 id="generating-events">Generating Events</h4>
<p>Now comes the fun part: actually programming the game mechanics. Essentially what we’d like to do is the following:</p>
<ol style="list-style-type: decimal">
<li>Generate an event for the player and enemy at the same time.</li>
<li>Process each event.</li>
<li>If either bot is dead, end the game and print an ending message.</li>
</ol>
<p>Here we’ll focus on (1), generating events. Let’s take a look at some code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genEvent ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">R.StdGen</span> <span class="dt">IO</span> <span class="dt">Event</span>
genEvent bot <span class="fu">=</span> <span class="kw">do</span>
    [n, m, r] <span class="ot">&lt;-</span> replicateM <span class="dv">3</span> <span class="fu">$</span> state (R.randomR (<span class="dv">0</span>, <span class="dv">100</span>))
    <span class="kw">let</span> dodge <span class="fu">=</span> n <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">*</span> bot<span class="fu">^.</span>dex <span class="ot">`div`</span> (bot<span class="fu">^.</span>dex <span class="fu">+</span> <span class="dv">50</span>)
        block <span class="fu">=</span> m <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">*</span> bot<span class="fu">^.</span>con <span class="ot">`div`</span> (bot<span class="fu">^.</span>con <span class="fu">+</span> <span class="dv">30</span>)
        dmg   <span class="fu">=</span> bot<span class="fu">^.</span>str <span class="fu">+</span> (bot<span class="fu">^.</span>str <span class="fu">*</span> r) <span class="ot">`div`</span> <span class="dv">30</span>
    return (dmg, dodge, block)</code></pre>
<p>In order to generate an event for a bot, we grab three numbers between 0 and 100:</p>
<ul>
<li>n, which helps determine if the bot dodges,</li>
<li>m, which helps determine if the bot blocks,</li>
<li>and r, which helps determine how much damage the bot does.</li>
</ul>
<p>We can use the <code>state</code> combinator here to lift the computation <code>(R.randomR (0, 100))</code> to a computation in the <code>StateT</code> monad. We then perform some arithmetic using the random numbers we grabbed along with the <code>dex</code>, <code>con</code>, and <code>str</code> stats from our <code>Bot</code>. We access these using the <code>^.</code> combinator from the <code>lens-family</code>, using the <code>Lens</code>es we defined above.</p>
<p>Important note: We are producing the amount of damage a bot <em>deals</em> here. We will want to process events according to how much damage each bot <em>receives</em>, which we’ll handle in a minute.</p>
<p>Now that we can generate single events, we need a way of mapping them to specific bots. We’ll define a new function, <code>genEventPair</code>, to generate <em>two</em> events at once, corresponding to the player and the enemy in the game.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genEventPair ::</span> <span class="dt">StateT</span> <span class="dt">BotState</span> <span class="dt">IO</span> (<span class="dt">Event</span>, <span class="dt">Event</span>)
genEventPair <span class="fu">=</span> <span class="kw">do</span>
    p <span class="ot">&lt;-</span> use player
    e <span class="ot">&lt;-</span> use enemy
    zoom generator <span class="fu">$</span> liftM2 switchDmgs (genEvent p) (genEvent e)
  <span class="kw">where</span>
    switchDmgs (a, b, c) (d, e, f) <span class="fu">=</span> ( (d, b, c), (a, e, f) )</code></pre>
<p>There are a couple of new things at play here. First, on <code>use</code>:</p>
<p>Note the use of our <code>Lens</code>es <code>player</code> and <code>enemy</code>. To access the underlying state in a <code>StateT</code>, we typically call the function <code>lift</code>. Here instead we call the function <code>use</code> from <code>Lens.Family2.State</code>, which allows us to specify which <em>piece</em> of our <code>BotState</code> we want to get. We do just this in order to generate events for both the <code>player</code> and <code>enemy</code>, using the aforementioned <code>Lens</code>es.</p>
<p>Next, if you were looking closely you might have noticed that <code>genEvent</code> isn’t operating in the same monad as <code>genEventPair</code>, yet we use <code>genEvent</code> inside of <code>genEventPair</code>! We are able do do this using the <code>zoom</code> combinator.</p>
<p><code>zoom</code> lifts a stateful operation on one field to a stateful operation on the entire state. Here, we’re zooming into <code>generator</code> (a <code>Lens</code> on our <code>StdGen</code>) and lifting the (stateful) generation of events for both the player and enemy into a (stateful) generation of <em>two</em> events while preserving player and enemy states. The fact that we can <code>zoom</code> into <code>genEvent</code> helps out the declaration immensely. It removes a lot of plumbing that we would have had to deal with in order to have <code>genEvent</code> operate on an underlying state of type <code>BotState</code> and allows the type of the computation to be more explicit.</p>
<p>Finally, Note the use of <code>switchDmgs</code> here: This was an ad hoc way to switch around damage dealt and damage sustained. <code>genEventPair</code> produces events harboring damage <em>taken</em>, which is what we need in order to process them in a nice way.</p>
<h4 id="processing-events">Processing Events</h4>
<p>Now that we’re able to generate events and keep track of our game state, the next thing we need to do is actually process these events and update game state. We introduce <code>resolveEvent</code> to take care of this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">resolveEvent ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (<span class="dt">Event</span>, <span class="dt">Event</span>) <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">BotState</span> m [(<span class="dt">Bot</span>, <span class="dt">Event</span>)]
resolveEvent (p_evt, e_evt) <span class="fu">=</span> <span class="kw">do</span>
    zoom player (resolve p_evt)
    zoom enemy  (resolve e_evt)
    p <span class="ot">&lt;-</span> use player
    e <span class="ot">&lt;-</span> use enemy
    return [(p, p_evt), (e, e_evt)]

<span class="ot">resolve ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">Bot</span> m ()
resolve (dmg, ddg, blk)
    <span class="fu">|</span> ddg       <span class="fu">=</span> return ()
    <span class="fu">|</span> blk       <span class="fu">=</span> hp <span class="fu">-=</span> dmg <span class="ot">`div`</span> <span class="dv">2</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> hp <span class="fu">-=</span> dmg</code></pre>
<p>First let’s look at the <code>resolve</code> function. Here we are taking an event and updating a <code>Bot</code>’s state based on that event. The implementation is straightforward, especially given that we have the <code>-=</code> <code>Lens</code> combinator at our disposal – this allows us to write imperative-looking code that does exactly what you would expect it to.</p>
<p>In the <code>resolveEvent</code> function, you should see some similarities to the above section. We can again use <code>zoom</code> and <code>use</code> in order to lift computations and retrieve state just as before, but we’re updating the main game state now. We produce two 2-tuples containing modified bots and their attached event that was processed during each turn.</p>
<p>At this point, the game logic is actually finished. We have ways to produce and deal with game events that modify game state, and provided that we can actually link these functions together (which we can, as we’ll see later), the game will actually run. All that we need to do now is handle IO and bot death. This is where <code>Pipes</code> comes in.</p>
<h4 id="pipes-and-io">Pipes and IO</h4>
<p>Let’s get the boring stuff out of the way first. I mentioned above that we have yet to deal with two major components of our game: IO and bot death. Let’s first define some simple functions to deal with these:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dead ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
dead <span class="fu">=</span> (<span class="fu">&lt;=</span> <span class="dv">0</span>) <span class="fu">.</span> view hp

<span class="ot">printBot ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printBot bot <span class="fu">=</span> putStrLn <span class="fu">$</span> bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; has &quot;</span> <span class="fu">++</span> show (bot<span class="fu">^.</span>hp) <span class="fu">++</span> <span class="st">&quot; hp remaining.&quot;</span>

<span class="ot">printEvent ::</span> <span class="dt">Bot</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printEvent bot (_, <span class="dt">True</span>, _) <span class="fu">=</span> putStrLn <span class="fu">$</span>
  bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; dodges the attack and takes no damage!&quot;</span>
printEvent bot (d, _, <span class="dt">True</span>) <span class="fu">=</span> putStrLn <span class="fu">$</span> 
  bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; blocks and takes half (&quot;</span> <span class="fu">++</span> show (d <span class="ot">`div`</span> <span class="dv">2</span>) <span class="fu">++</span> <span class="st">&quot;) damage!&quot;</span>
printEvent bot (d, _,    _) <span class="fu">=</span> putStrLn <span class="fu">$</span> 
  bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; takes &quot;</span> <span class="fu">++</span> show d <span class="fu">++</span> <span class="st">&quot; damage.&quot;</span></code></pre>
<p>Here we again make use of our <code>Lens</code>es (these are handy, huh?). We use the <code>view</code> function in order to get the health of our bot in <code>dead</code>, and check whether its hp is less than 0 in the usual fashion. <code>view</code> is just a prefix synonym for the infix <code>^.</code> that we’ve been using all this time. Speaking of which, we use the <code>^.</code> combinator heavily in both <code>printEvent</code> and <code>printBot</code> to handle the string-handling plumbing. Since these functions essentially tell you what they’re doing implicitly, I’ll omit an extensive explanation.</p>
<p>Now that we have ways to print <code>Bot</code>s and <code>Event</code>s and check for bot death, the last thing we need to do is actually perform these things the context of our game. A <code>Consumer</code> from the <code>Pipes</code> library will handle this nicely for us:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printGame ::</span> <span class="dt">Consumer</span> [(<span class="dt">Bot</span>, <span class="dt">Event</span>)] (<span class="dt">StateT</span> <span class="dt">BotState</span> <span class="dt">IO</span>) ()
printGame <span class="fu">=</span> <span class="kw">do</span>
    botEvents<span class="fu">@</span>[(b1, e1), (b2, e2)] <span class="ot">&lt;-</span> await
    (lift <span class="fu">.</span> lift) <span class="fu">$</span> <span class="kw">do</span>
        forM_ botEvents <span class="fu">$</span> \be<span class="fu">@</span>(bot, event) <span class="ot">-&gt;</span> <span class="kw">do</span>
            uncurry printEvent be
            printBot bot
            threadDelay <span class="dv">500000</span>
            when (dead bot) <span class="fu">$</span> putStrLn <span class="fu">$</span> bot<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; died!&quot;</span>
        putStrLn <span class="fu">$</span> <span class="kw">case</span> (dead b1, dead b2) <span class="kw">of</span>
            (<span class="dt">True</span> , <span class="dt">True</span> ) <span class="ot">-&gt;</span> <span class="st">&quot;It was a tie!&quot;</span>
            (<span class="dt">True</span> , <span class="dt">False</span>) <span class="ot">-&gt;</span> b2<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; wins!&quot;</span>
            (<span class="dt">False</span>, <span class="dt">True</span> ) <span class="ot">-&gt;</span> b1<span class="fu">^.</span>name <span class="fu">++</span> <span class="st">&quot; wins!&quot;</span>
            _              <span class="ot">-&gt;</span> <span class="st">&quot;-----------------&quot;</span>
    unless (any (dead <span class="fu">.</span> fst) botEvents) printGame</code></pre>
<p>We <code>await</code> two <code>(Bot, Event)</code>s (from where, you might ask? We’ll see in a moment.) and essentially handle all of the plumbing here. For each pair of bots and events, we print the event, print the bot, then wait half a second with <code>threadDelay</code> (otherwise the game would run too quickly and we wouldn’t see it play out). With a <code>Consumer</code> like this, we need to loop until we’ve consumed all of the input we want, so we use the <code>when</code> and <code>unless</code> functions from <code>Control.Monad</code> as indicators of when to do so. If a bot dies, we stop – we also print out some information about who died and who won the game.</p>
<h4 id="running-the-game">Running the Game</h4>
<p>Okay, so I say that we have everything we need now, but you might ask…how do I run this? Let’s take a look at a program that pits two bots – a good guy and a bad guy – against one another, and we’ll dissect it.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runGame ::</span> <span class="dt">IO</span> ()
runGame <span class="fu">=</span> <span class="kw">do</span>
    gen <span class="ot">&lt;-</span> R.getStdGen
    <span class="kw">let</span> player <span class="fu">=</span> <span class="dt">Bot</span> <span class="st">&quot;The Good Guy&quot;</span> <span class="dv">19</span> <span class="dv">13</span> <span class="dv">12</span> <span class="dv">200</span>
        enemy  <span class="fu">=</span> <span class="dt">Bot</span> <span class="st">&quot;The Bad Guy&quot;</span>  <span class="dv">14</span> <span class="dv">6</span>  <span class="dv">10</span> <span class="dv">200</span>
        startState <span class="fu">=</span> (gen, (player, enemy))
    flip evalStateT startState 
      <span class="fu">$</span> runEffect 
      <span class="fu">$</span> lift (genEventPair <span class="fu">&gt;&gt;=</span> resolveEvent) <span class="fu">&gt;~</span> printGame</code></pre>
<p>In the first few lines, we simply set up an initial state for the game. The real “stuff” happens in the line starting with <code>flip evalStateT</code>. We’ll work through this at a type level from the inside-out. First, we perform <code>genEventPair &gt;&gt;= resolveEvent</code>, which effectively handles the logic we talked about earlier and produces a <code>StateT BotState IO [(Bot, Event)]</code>. From here, we <code>lift</code> the computation into an <code>Effect (StateT BotState IO) [(Bot, Event)]</code>, which we then repeatedly pipe into <code>printGame</code> with <code>&gt;~</code>. After all of this, we <code>runEffect</code> to extract the <code>StateT BotState IO [(Bot, Event)]</code> from the computation, and finally evaluate the function using <code>evalStateT</code>. Phew!</p>
<p>In any case, we can now run our program and execute the game…</p>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; runGame
The Good Guy takes <span class="dv">15</span> damage.
The Good Guy has <span class="dv">285</span> hp remaining.
The Bad Guy takes <span class="dv">29</span> damage.
The Bad Guy has <span class="dv">171</span> hp remaining.
-----------------
The Good Guy dodges the attack and takes no damage!
The Good Guy has <span class="dv">285</span> hp remaining.
The Bad Guy takes <span class="dv">20</span> damage.
The Bad Guy has <span class="dv">151</span> hp remaining.
-----------------
The Good Guy blocks and takes half (<span class="dv">24</span>) damage!
The Good Guy has <span class="dv">261</span> hp remaining.
The Bad Guy takes <span class="dv">34</span> damage.
The Bad Guy has <span class="dv">117</span> hp remaining.
-----------------
The Good Guy takes <span class="dv">46</span> damage.
The Good Guy has <span class="dv">215</span> hp remaining.
The Bad Guy takes <span class="dv">19</span> damage.
The Bad Guy has <span class="dv">98</span> hp remaining.
-----------------
The Good Guy takes <span class="dv">32</span> damage.
The Good Guy has <span class="dv">183</span> hp remaining.
The Bad Guy takes <span class="dv">37</span> damage.
The Bad Guy has <span class="dv">61</span> hp remaining.
-----------------
The Good Guy dodges the attack and takes no damage!
The Good Guy has <span class="dv">183</span> hp remaining.
The Bad Guy takes <span class="dv">12</span> damage.
The Bad Guy has <span class="dv">49</span> hp remaining.
-----------------
The Good Guy takes <span class="dv">24</span> damage.
The Good Guy has <span class="dv">159</span> hp remaining.
The Bad Guy takes <span class="dv">23</span> damage.
The Bad Guy has <span class="dv">26</span> hp remaining.
-----------------
The Good Guy dodges the attack and takes no damage!
The Good Guy has <span class="dv">159</span> hp remaining.
The Bad Guy takes <span class="dv">36</span> damage.
The Bad Guy has -<span class="dv">10</span> hp remaining.
The Bad Guy died!
The Good Guy wins!</code></pre>
<p>…and behold, the good guy wins (this time)!</p>
<p><a href="https://gist.github.com/5outh/8049361">View full source on GitHub</a>.</p>
<p>- Ben</p>
</div>

	    	<a class="disqus_link" href="./posts/2013-12-19-bots4-clone.html#disqus_thread"></a>
    	</li>
    
    	<li>
	    	<div class="post_header">
	<a class="post_title" href="./posts/2013-11-13-parsing-negating.html">Parsing and Negating Boolean Strings in Haskell</a>
	<p class="published">Published by Ben Kovach on November 13, 2013</p>
</div>
<div class="post_body">
	<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>
 
<span class="kw">import </span><span class="dt">Text.ParserCombinators.Parsec</span>
<span class="kw">import </span><span class="dt">Text.ParserCombinators.Parsec.Token</span> <span class="kw">hiding</span> (parens)
<span class="kw">import </span><span class="dt">Text.ParserCombinators.Parsec.Expr</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span> <span class="kw">hiding</span> ((&lt;|&gt;))
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (not)</code></pre>
<p>It appears that <a href="http://www.reddit.com/r/dailyprogrammer/">the dailyprogrammer subreddit</a> is back after a pretty long hiatus, and they kicked back into gear with a really interesting problem. The problem was, paraphrasing:</p>
<blockquote>
<p>Given a Boolean expression as a string S, compute and print the negation of S as a string using DeMorgan’s laws.</p>
</blockquote>
<p><a href="http://www.reddit.com/r/dailyprogrammer/comments/1qira9/111213_challenge_135_intermediate_de_morgans_law/">The problem is also detailed in full here</a>. I completed the challenge and posted my solution to reddit, but wanted to share it here as well, so here it is, with slight modifications:</p>
<p>This is a problem that is heavily suited to three major things that Haskell advocates: Algebraic Data Types, Pattern Matching, and Monadic Parsing. First off, if you’ve had any experience with automata theory, it’s pretty clear that the input language of Boolean expressions can be represented by a <a href="http://en.wikipedia.org/wiki/Context-free_grammar">context free grammar</a>. It just so happens that Haskell makes it incredibly easy to model CFGs right out of the box using Algebraic Data Types.</p>
<p>Let’s take a look at this data type representing Boolean expressions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Not</span> <span class="dt">Expr</span> 
          <span class="fu">|</span> <span class="dt">And</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
          <span class="fu">|</span> <span class="dt">Or</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
          <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Char</span> 
          <span class="fu">|</span> <span class="dt">SubExpr</span> <span class="dt">Expr</span> 
          <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre>
<p>Simple. Now, the main problem of this challenge was actually performing the simplification of the not operation. Using pattern matching, we can <em>directly encode these rules</em> in the following manner:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">not<span class="ot"> ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
not (<span class="dt">Not</span> e)     <span class="fu">=</span> e
not (<span class="dt">And</span> e1 e2) <span class="fu">=</span> <span class="dt">Or</span> (not e1) (not e2)
not (<span class="dt">Or</span> e1 e2)  <span class="fu">=</span> <span class="dt">And</span> (not e1) (not e2)
not (<span class="dt">Var</span> c)     <span class="fu">=</span> <span class="dt">Not</span> (<span class="dt">Var</span> c)
not (<span class="dt">SubExpr</span> e) <span class="fu">=</span> not e</code></pre>
<p>Here we’re giving a literal definition of rules for negating Boolean expressions. If you use Haskell, this is really easy to read. If you don’t: stare at it for a second; you’ll see what it’s doing! That’s the brunt of the challenge, right there. That’s it. Encode a Boolean expression into an <code>Expr</code> and call <code>not</code> on it, and it will spit out a new <code>Expr </code>expressing the negation of your original expression. DeMorgan’s laws are represented in the <code>And</code> and <code>Or</code> rules.We can also do this in a slightly modified way, using a function <code>simplify :: Expr -&gt; Expr</code> that simplifies expressions and another function <code>not = simplify . Not</code> to compute the same thing. It’s a similar solution so I won’t post it, but if you’d like to, feel free to experiment and/or add more simplification rules (e.g. <code>simplify e@(And a b) = if a == b then a else e</code>). We can also display our expressions as a string by declaring <code>Expr</code> an instance of <code>Show</code> in the following way:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span>
  show (<span class="dt">Not</span> e)     <span class="fu">=</span> <span class="st">&quot;NOT &quot;</span> <span class="fu">++</span> show e
  show (<span class="dt">And</span> e1 e2) <span class="fu">=</span> show e1 <span class="fu">++</span> <span class="st">&quot; AND &quot;</span> <span class="fu">++</span> show e2
  show (<span class="dt">Or</span> e1 e2)  <span class="fu">=</span> show e1 <span class="fu">++</span> <span class="st">&quot; OR &quot;</span>  <span class="fu">++</span> show e2
  show (<span class="dt">Var</span> c)     <span class="fu">=</span> [c]
  show (<span class="dt">SubExpr</span> e) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show e <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre>
<p>Now we can type in Boolean expressions using our data type, not them, and print them out as nice expressions. But, now we are faced with, in my opinion, the tougher part of the challenge. We’re able to actually compute everything we need to, but what about parsing a Boolean expression (as a string) into an <code>Expr</code>? We can use a monadic parsing library, namely Haskell’s beloved <a href="http://www.haskell.org/haskellwiki/Parsec">Parsec</a>, to do this in a rather simple way. We’ll be using Parsec’s <a href="http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Token.html">Token</a> and <a href="http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Expr.html">Expr</a> libraries, as well as the base, in this example. Let’s take a look.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span>
parseExpr <span class="fu">=</span> parse expr <span class="st">&quot;&quot;</span>
  <span class="kw">where</span> expr      <span class="fu">=</span> buildExpressionParser operators term <span class="fu">&lt;?&gt;</span> <span class="st">&quot;compound expression&quot;</span>
        term      <span class="fu">=</span>  parens expr <span class="fu">&lt;|&gt;</span> variable <span class="fu">&lt;?&gt;</span> <span class="st">&quot;full expression&quot;</span>
        operators <span class="fu">=</span> [ [<span class="dt">Prefix</span> (string <span class="st">&quot;NOT&quot;</span> <span class="fu">&gt;&gt;</span> spaces <span class="fu">&gt;&gt;</span> return <span class="dt">Not</span>)]
                    , [binary <span class="st">&quot;AND&quot;</span> <span class="dt">And</span>]
                    , [binary <span class="st">&quot;OR&quot;</span> <span class="dt">Or</span>] ]
          <span class="kw">where</span> binary n c <span class="fu">=</span> <span class="dt">Infix</span> (string n <span class="fu">*&gt;</span> spaces <span class="fu">*&gt;</span> pure c) <span class="dt">AssocLeft</span>
        variable <span class="fu">=</span> <span class="dt">Var</span>     <span class="fu">&lt;$&gt;</span> (letter <span class="fu">&lt;*</span> spaces)                              
                           <span class="fu">&lt;?&gt;</span> <span class="st">&quot;variable&quot;</span>
        parens p <span class="fu">=</span> <span class="dt">SubExpr</span> <span class="fu">&lt;$&gt;</span> (char <span class="ch">'('</span> <span class="fu">*&gt;</span> spaces <span class="fu">*&gt;</span> p <span class="fu">&lt;*</span> char <span class="ch">')'</span> <span class="fu">&lt;*</span> spaces) 
                           <span class="fu">&lt;?&gt;</span> <span class="st">&quot;parens&quot;</span></code></pre>
<p>We essentially define the structure of our input here and parse it into an Expr using a bunch of case-specific parsing rules. <code>variable</code> parses a single <code>char</code> into a <code>Var</code>, <code>parens</code> matches and returns a <code>SubExpr</code>, and everything else is handled by using the convenience function <code>buildExpressionParser</code> along with a list of operator strings, the types they translate to and their operator precedence. Here we’re using applicative style to do our parsing, but monadic style is fine too. <a href="http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/">Check this out for more on applicative style parsing</a>.</p>
<p>Given that, we can define a <code>main</code> function to read in a file of expressions and output the negation of each of the expressions, like so:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> mapM_ printNotExpr <span class="fu">.</span> lines <span class="fu">=&lt;&lt;</span> readFile <span class="st">&quot;inputs.txt&quot;</span>
  <span class="kw">where</span> printNotExpr e <span class="fu">=</span> <span class="kw">case</span> parseExpr e <span class="kw">of</span>
                          <span class="dt">Right</span> x <span class="ot">-&gt;</span> print <span class="fu">$</span> not x
                          <span class="dt">Left</span>  e <span class="ot">-&gt;</span> error <span class="fu">$</span> show e</code></pre>
<p>Concise and to the point. We make sure that each line gets parsed properly, not the expressions, and print them. Here’s what we get when we run the program:</p>
<pre><code>inputs.txt                             --- output

a                                      --- NOT a
NOT a                                  --- a
a AND b                                --- NOT a OR NOT b 
NOT a AND b                            --- a OR NOT b
NOT (a AND b)                          --- a AND b
NOT (a OR b AND c) OR NOT(a AND NOT b) --- (a OR b AND c) AND (a AND NOT b)</code></pre>
<p><a href="https://gist.github.com/5outh/7452588#file-demorgan-hs">Finally, here’s the full source on Github</a>.</p>
<p>Thanks for reading!</p>
</div>

	    	<a class="disqus_link" href="./posts/2013-11-13-parsing-negating.html#disqus_thread"></a>
    	</li>
    
</ul>
<p style="text-align:right; font-weight:bold">Looking for an older post? <a href="archive.html">Check out the archive</a>.</p>
            </div>
    <footer>
        <p id="copyright">© Benjamin Kovach, 2013 <br />
                          Follow me on <a href="http://github.com/5outh">GitHub</a> and <a href="http://twitter.com/bendotk">Twitter</a>!
        <p style="float:left; padding-top:20px" id="coin_donate"><a href="bitcoin:1B3W1myNbBoUKsuBKwMKNZg1eBdjnLrCrV">Donate Bitcoins</a></p>
            </div>
            </p>
    </footer>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'abstract-nonsense'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
    
    </body>     
</html>